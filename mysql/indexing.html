<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indexing & Performance - MySQL Interview</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="bg-animation"></div>

    <nav class="top-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-logo"><i class="fas fa-rocket"></i><span>Interview Hub</span></a>
            <a href="sql-fundamentals.html" class="nav-back"><i class="fas fa-arrow-left"></i> SQL Fundamentals</a>
        </div>
    </nav>

    <header class="topic-header">
        <div class="topic-icon mysql"><i class="fas fa-search"></i></div>
        <div class="topic-info">
            <span class="topic-category">MySQL</span>
            <h1>Indexing & Performance</h1>
            <p class="topic-desc">B-Tree, Index Types, Composite Index, EXPLAIN, Query Optimization</p>
        </div>
    </header>

    <main class="content-container">
        <aside class="toc">
            <h3><i class="fas fa-list"></i> Ná»™i dung</h3>
            <ul>
                <li><a href="#how-index">How Indexes Work</a></li>
                <li><a href="#types">Index Types</a></li>
                <li><a href="#composite">Composite Index</a></li>
                <li><a href="#covering">Covering Index</a></li>
                <li><a href="#explain">EXPLAIN Analysis</a></li>
                <li><a href="#optimization">Query Optimization</a></li>
                <li><a href="#antipatterns">Anti-Patterns</a></li>
                <li><a href="#maintenance">Index Maintenance</a></li>
                <li><a href="#interview">CÃ¢u há»i phá»ng váº¥n</a></li>
            </ul>
        </aside>

        <article class="main-content">
            <!-- HOW INDEXES WORK -->
            <section class="content-section">
                <h2 id="how-index" class="section-title"><span class="section-icon">ğŸŒ³</span>How Indexes Work</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>B-Tree Structure</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Visual</span><span
                                    class="code-title">B-Tree Index Structure</span></div>
                            <pre><code>                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚    Root Node           â”‚
                        â”‚   [50 | 100 | 150]     â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼                     â–¼                     â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ [10,25,40]  â”‚      â”‚ [60,75,90]  â”‚      â”‚[120,140,180]â”‚  Branch Nodes
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚                   â”‚                    â”‚
     â”Œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”
     â–¼     â–¼     â–¼       â–¼     â–¼     â–¼        â–¼    â–¼     â–¼
   â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”    â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”
   â”‚10 â”‚â–ºâ”‚25 â”‚â–ºâ”‚40 â”‚   â”‚60 â”‚â–ºâ”‚75 â”‚â–ºâ”‚90 â”‚    â”‚120â”‚â–ºâ”‚140â”‚â–ºâ”‚180â”‚  Leaf Nodes
   â”‚ptrâ”‚ â”‚ptrâ”‚ â”‚ptrâ”‚   â”‚ptrâ”‚ â”‚ptrâ”‚ â”‚ptrâ”‚    â”‚ptrâ”‚ â”‚ptrâ”‚ â”‚ptrâ”‚  (Linked List)
   â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜    â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜

Key characteristics:
â€¢ Self-balancing: All leaves at same depth
â€¢ Each node can have multiple children (branching factor ~100-1000)
â€¢ Leaf nodes linked for range scans
â€¢ Lookup: O(log n) - typically 3-4 disk reads for millions of rows</code></pre>
                        </div>

                        <div class="two-column">
                            <div class="column highlight-box">
                                <h4>âœ… Khi nÃªn dÃ¹ng Index</h4>
                                <ul>
                                    <li>Columns trong WHERE clause</li>
                                    <li>JOIN columns (foreign keys)</li>
                                    <li>ORDER BY columns</li>
                                    <li>High cardinality columns</li>
                                    <li>Frequent SELECT queries</li>
                                </ul>
                            </div>
                            <div class="column highlight-box">
                                <h4>âŒ Khi KHÃ”NG nÃªn dÃ¹ng</h4>
                                <ul>
                                    <li>Tables ráº¥t nhá»</li>
                                    <li>Columns Ã­t Ä‘Æ°á»£c query</li>
                                    <li>Low cardinality (boolean, status)</li>
                                    <li>Heavy INSERT/UPDATE tables</li>
                                    <li>Wide columns (TEXT, BLOB)</li>
                                </ul>
                            </div>
                        </div>

                        <div class="key-points">
                            <h4><i class="fas fa-key"></i> Index Trade-offs</h4>
                            <ul>
                                <li><strong>Read Performance:</strong> âœ… Faster SELECT queries</li>
                                <li><strong>Write Performance:</strong> âŒ Slower INSERT/UPDATE/DELETE (index
                                    maintenance)</li>
                                <li><strong>Storage:</strong> âŒ Extra disk space (cÃ³ thá»ƒ 10-30% table size)</li>
                                <li><strong>Maintenance:</strong> âŒ Index fragmentation over time</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Clustered vs Non-Clustered</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Visual</span><span
                                    class="code-title">Clustered vs Secondary Index</span></div>
                            <pre><code>CLUSTERED INDEX (PRIMARY KEY in InnoDB):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Index: B-Tree                                               â”‚
â”‚ Leaf nodes contain: ACTUAL ROW DATA                         â”‚
â”‚                                                             â”‚
â”‚ [PK=1] â†’ {id:1, name:'Alice', email:'alice@...', ...}      â”‚
â”‚ [PK=2] â†’ {id:2, name:'Bob', email:'bob@...', ...}          â”‚
â”‚ [PK=3] â†’ {id:3, name:'Charlie', email:'charlie@...', ...}  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â€¢ Table data physically ordered by PK
â€¢ Only ONE clustered index per table
â€¢ Sequential PK = good for inserts (append)
â€¢ Random PK (UUID) = bad for inserts (page splits)


SECONDARY INDEX (Non-Clustered):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Index on (email)                                            â”‚
â”‚ Leaf nodes contain: email â†’ PRIMARY KEY pointer             â”‚
â”‚                                                             â”‚
â”‚ ['alice@...'] â†’ PK=1 â”€â”€â”€â”€â”€â”                                â”‚
â”‚ ['bob@...']   â†’ PK=2 â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º Lookup in Clustered Index  â”‚
â”‚ ['charlie@...'] â†’ PK=3 â”€â”€â”€â”˜     to get full row            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â€¢ Lookup: Index â†’ PK â†’ Row (double lookup)
â€¢ Covering index avoids second lookup</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>Clustered vs Secondary Index</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Aspect</th>
                                        <th>Clustered (PK)</th>
                                        <th>Secondary</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Per table</td>
                                        <td>Exactly 1</td>
                                        <td>Multiple allowed</td>
                                    </tr>
                                    <tr>
                                        <td>Leaf nodes</td>
                                        <td>Actual row data</td>
                                        <td>PK pointer</td>
                                    </tr>
                                    <tr>
                                        <td>Row access</td>
                                        <td>Direct</td>
                                        <td>Via PK lookup</td>
                                    </tr>
                                    <tr>
                                        <td>Storage</td>
                                        <td>Table = Index</td>
                                        <td>Separate structure</td>
                                    </tr>
                                    <tr>
                                        <td>Range scans</td>
                                        <td>Very fast</td>
                                        <td>Depends on PK order</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- INDEX TYPES -->
            <section class="content-section">
                <h2 id="types" class="section-title"><span class="section-icon">ğŸ“‘</span>Index Types</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>MySQL Index Types</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="comparison-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>PRIMARY KEY</strong></td>
                                        <td>Unique, NOT NULL, clustered</td>
                                        <td>Row identifier</td>
                                    </tr>
                                    <tr>
                                        <td><strong>UNIQUE INDEX</strong></td>
                                        <td>No duplicates (allows NULL)</td>
                                        <td>Email, SSN, username</td>
                                    </tr>
                                    <tr>
                                        <td><strong>INDEX (B-Tree)</strong></td>
                                        <td>Standard index</td>
                                        <td>WHERE, JOIN, ORDER</td>
                                    </tr>
                                    <tr>
                                        <td><strong>FULLTEXT</strong></td>
                                        <td>Text search</td>
                                        <td>Search in articles, descriptions</td>
                                    </tr>
                                    <tr>
                                        <td><strong>SPATIAL</strong></td>
                                        <td>Geometric data (R-Tree)</td>
                                        <td>GIS, location queries</td>
                                    </tr>
                                    <tr>
                                        <td><strong>HASH (Memory)</strong></td>
                                        <td>Exact match only</td>
                                        <td>Memory engine, exact lookups</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Creating
                                    Indexes</span></div>
                            <pre><code class="language-sql">-- Primary Key (clustered, auto-created)
CREATE TABLE users (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Unique Index
CREATE UNIQUE INDEX idx_users_email ON users(email);

-- Standard B-Tree Index
CREATE INDEX idx_users_name ON users(name);

-- Composite Index (multiple columns)
CREATE INDEX idx_users_status_created ON users(status, created_at);

-- Prefix Index (for long strings - first N characters)
CREATE INDEX idx_users_email_prefix ON users(email(20));

-- Fulltext Index
CREATE FULLTEXT INDEX idx_ft_content ON articles(title, content);

-- Descending Index (MySQL 8.0+)
CREATE INDEX idx_created_desc ON orders(created_at DESC);

-- Invisible Index (for testing - not used by optimizer)
CREATE INDEX idx_test ON users(phone) INVISIBLE;

-- Drop Index
DROP INDEX idx_users_name ON users;
ALTER TABLE users DROP INDEX idx_users_email;

-- View existing indexes
SHOW INDEX FROM users;
SHOW CREATE TABLE users;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Fulltext
                                    Search</span></div>
                            <pre><code class="language-sql">-- Create fulltext index
CREATE FULLTEXT INDEX idx_ft_articles ON articles(title, content);

-- Natural Language Mode (default)
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('database optimization');

-- Boolean Mode (operators: +, -, *, >, <, ())
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('+MySQL -PostgreSQL' IN BOOLEAN MODE);

-- With expansion (find related words)
SELECT * FROM articles
WHERE MATCH(title, content) AGAINST('database' WITH QUERY EXPANSION);

-- Get relevance score
SELECT 
    title,
    MATCH(title, content) AGAINST('database') AS relevance
FROM articles
WHERE MATCH(title, content) AGAINST('database')
ORDER BY relevance DESC;</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- COMPOSITE INDEX -->
            <section class="content-section">
                <h2 id="composite" class="section-title"><span class="section-icon">ğŸ”—</span>Composite Index</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Leftmost Prefix Rule</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Composite Index Example</span></div>
                            <pre><code class="language-sql">-- Composite index on (a, b, c)
CREATE INDEX idx_abc ON orders(status, user_id, created_at);

-- LEFTMOST PREFIX RULE: Index used for queries on leftmost columns

-- âœ… Uses index (full)
SELECT * FROM orders WHERE status = 'ACTIVE' AND user_id = 1 AND created_at > '2024-01-01';

-- âœ… Uses index (a, b)
SELECT * FROM orders WHERE status = 'ACTIVE' AND user_id = 1;

-- âœ… Uses index (a only)
SELECT * FROM orders WHERE status = 'ACTIVE';

-- âŒ KHÃ”NG dÃ¹ng index (skip column a)
SELECT * FROM orders WHERE user_id = 1;

-- âŒ KHÃ”NG dÃ¹ng index (chá»‰ column c)
SELECT * FROM orders WHERE created_at > '2024-01-01';

-- âœ… Uses index (a, b) - c skipped but a,b still used
SELECT * FROM orders WHERE status = 'ACTIVE' AND user_id = 1 AND amount > 100;

-- âš ï¸ Partial use (a only) - because b uses range
SELECT * FROM orders WHERE status = 'ACTIVE' AND user_id > 1 AND created_at > '2024-01-01';
-- Range condition on user_id "breaks" index for created_at</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Visual</span><span class="code-title">Index
                                    Column Order</span></div>
                            <pre><code>Index on (status, user_id, created_at):

                status = 'ACTIVE'
               /                  \
        user_id = 1            user_id = 2
       /    |    \            /    |    \
    Jan1  Jan2  Jan3       Feb1  Feb2  Feb3
    
Queries:
â€¢ WHERE status = 'ACTIVE'                          â†’ Uses index (a)
â€¢ WHERE status = 'ACTIVE' AND user_id = 1          â†’ Uses index (a, b)
â€¢ WHERE status = 'ACTIVE' AND user_id = 1 AND date â†’ Uses index (a, b, c)
â€¢ WHERE user_id = 1                                â†’ âŒ No leftmost prefix

Best practices for column order:
1. Equality conditions first (=, IN)
2. Range conditions last (>, <, BETWEEN, LIKE 'abc%')
3. High cardinality columns early (more selective)
4. Consider ORDER BY columns</code></pre>
                        </div>

                        <div class="info-box">
                            <h4><i class="fas fa-lightbulb"></i> Composite Index Tips</h4>
                            <ul>
                                <li><strong>Column order matters:</strong> Put equality columns first, range columns
                                    last</li>
                                <li><strong>Selectivity:</strong> High cardinality columns early (more filter power)
                                </li>
                                <li><strong>Common queries:</strong> Design index order based on most frequent queries
                                </li>
                                <li><strong>Don't over-index:</strong> 3-4 columns usually max, more = maintenance cost
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- COVERING INDEX -->
            <section class="content-section">
                <h2 id="covering" class="section-title"><span class="section-icon">ğŸ“¦</span>Covering Index</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Using index for all columns</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Covering
                                    Index Example</span></div>
                            <pre><code class="language-sql">-- Table structure
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT,
    status VARCHAR(20),
    amount DECIMAL(10,2),
    created_at TIMESTAMP,
    -- ... many more columns
);

-- Standard index
CREATE INDEX idx_user_status ON orders(user_id, status);

-- Query WITHOUT covering (needs row lookup)
SELECT id, user_id, status, amount  -- amount not in index!
FROM orders 
WHERE user_id = 123 AND status = 'ACTIVE';
-- Process: Index â†’ Find PK â†’ Go to table â†’ Get amount

-- Covering index (includes all SELECT columns)
CREATE INDEX idx_covering ON orders(user_id, status, amount);

-- Query WITH covering (index only!)
SELECT user_id, status, amount
FROM orders 
WHERE user_id = 123 AND status = 'ACTIVE';
-- Process: Index only - no table lookup needed!

-- Check EXPLAIN for "Using index" (covering)
EXPLAIN SELECT user_id, status, amount FROM orders WHERE user_id = 123;
-- Extra column: "Using index" = covering index used</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>Regular vs Covering Index</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Aspect</th>
                                        <th>Regular Index</th>
                                        <th>Covering Index</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Disk I/O</td>
                                        <td>Index + Table lookup</td>
                                        <td>Index only</td>
                                    </tr>
                                    <tr>
                                        <td>Speed</td>
                                        <td>Good</td>
                                        <td>Excellent</td>
                                    </tr>
                                    <tr>
                                        <td>Index size</td>
                                        <td>Smaller</td>
                                        <td>Larger (more columns)</td>
                                    </tr>
                                    <tr>
                                        <td>Write overhead</td>
                                        <td>Lower</td>
                                        <td>Higher</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> Covering Index Trade-offs</h4>
                            <ul>
                                <li><strong>Pro:</strong> Eliminates table lookup - major performance gain</li>
                                <li><strong>Con:</strong> Larger index size = more memory, disk, maintenance</li>
                                <li><strong>Best for:</strong> Frequent queries with specific column needs</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- EXPLAIN -->
            <section class="content-section">
                <h2 id="explain" class="section-title"><span class="section-icon">ğŸ”</span>EXPLAIN Analysis</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Reading EXPLAIN Output</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">EXPLAIN
                                    Examples</span></div>
                            <pre><code class="language-sql">-- Basic EXPLAIN
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- EXPLAIN ANALYZE (actual execution - MySQL 8.0.18+)
EXPLAIN ANALYZE SELECT * FROM users WHERE status = 'ACTIVE';

-- EXPLAIN FORMAT=JSON (detailed)
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE id = 1;

-- EXPLAIN FORMAT=TREE (execution tree)
EXPLAIN FORMAT=TREE SELECT * FROM users WHERE status = 'ACTIVE';</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>EXPLAIN Output Columns</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Column</th>
                                        <th>Description</th>
                                        <th>What to look for</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>type</strong></td>
                                        <td>Join type</td>
                                        <td>Best to worst: const â†’ eq_ref â†’ ref â†’ range â†’ index â†’ ALL</td>
                                    </tr>
                                    <tr>
                                        <td><strong>possible_keys</strong></td>
                                        <td>Candidate indexes</td>
                                        <td>Available indexes for query</td>
                                    </tr>
                                    <tr>
                                        <td><strong>key</strong></td>
                                        <td>Chosen index</td>
                                        <td>NULL = no index used</td>
                                    </tr>
                                    <tr>
                                        <td><strong>key_len</strong></td>
                                        <td>Index bytes used</td>
                                        <td>How much of composite index</td>
                                    </tr>
                                    <tr>
                                        <td><strong>rows</strong></td>
                                        <td>Estimated rows</td>
                                        <td>Lower is better</td>
                                    </tr>
                                    <tr>
                                        <td><strong>filtered</strong></td>
                                        <td>% rows filtered</td>
                                        <td>Higher is better (more filtered out)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Extra</strong></td>
                                        <td>Additional info</td>
                                        <td>Watch for: Using filesort, Using temporary</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Type
                                    Column Values (best â†’ worst)</span></div>
                            <pre><code>TYPE values ranked by efficiency:

1. system     â†’ Table has 1 row (system table)
2. const      â†’ PK/Unique lookup, 1 row max
3. eq_ref     â†’ PK/Unique JOIN, 1 row per table
4. ref        â†’ Non-unique index lookup
5. fulltext   â†’ Fulltext index
6. ref_or_null â†’ ref + NULL check
7. index_merge â†’ Multiple indexes merged
8. range      â†’ Range scan (BETWEEN, >, <)
9. index      â†’ Full index scan (reading all index)
10. ALL       â†’ Full table scan âŒ BAD!

EXTRA values to watch:
âœ… Good:
   â€¢ Using index            â†’ Covering index (no table lookup)
   â€¢ Using index condition  â†’ Index condition pushdown

âš ï¸ Needs attention:
   â€¢ Using where           â†’ Filtering after fetch (normal, but check)
   
âŒ Bad (try to eliminate):
   â€¢ Using filesort        â†’ Extra sorting pass (no index for ORDER)
   â€¢ Using temporary       â†’ Temp table needed (GROUP BY/DISTINCT)
   â€¢ Using join buffer     â†’ JOIN without index</code></pre>
                        </div>
                    </div>
                </div>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>EXPLAIN ANALYZE</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">EXPLAIN
                                    ANALYZE Output</span></div>
                            <pre><code class="language-sql">EXPLAIN ANALYZE SELECT u.name, COUNT(o.id)
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE u.status = 'ACTIVE'
GROUP BY u.id;

/* Output example:
-> Group aggregate: count(o.id)  (cost=150.25..150.25 rows=100)
    -> Nested loop left join  (cost=50.25 rows=500)
        -> Index lookup on u using idx_status (status='ACTIVE')
           (cost=10.25 rows=100) (actual time=0.138..0.842 rows=100 loops=1)
        -> Index lookup on o using idx_user_id (user_id=u.id)
           (cost=0.40 rows=5) (actual time=0.025..0.087 rows=5 loops=100)

Key metrics:
â€¢ cost: Optimizer's estimated cost
â€¢ rows: Estimated row count
â€¢ actual time: first_row_time..last_row_time (milliseconds)
â€¢ loops: How many times this step executed
*/</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- QUERY OPTIMIZATION -->
            <section class="content-section">
                <h2 id="optimization" class="section-title"><span class="section-icon">âš¡</span>Query Optimization</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Common Optimizations</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Optimization Techniques</span></div>
                            <pre><code class="language-sql">-- 1. AVOID SELECT * (fetch only needed columns)
-- âŒ Bad
SELECT * FROM users WHERE status = 'ACTIVE';

-- âœ… Good
SELECT id, name, email FROM users WHERE status = 'ACTIVE';


-- 2. USE COVERING INDEX
CREATE INDEX idx_covering ON users(status, id, name, email);


-- 3. PAGINATION: Avoid large OFFSET
-- âŒ Slow (scans 100000 rows then discards)
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 100000;

-- âœ… Keyset pagination (much faster)
SELECT * FROM users WHERE id > 100000 ORDER BY id LIMIT 10;

-- âœ… With last seen ID
SELECT * FROM users WHERE id > :last_id ORDER BY id LIMIT 10;


-- 4. COUNT OPTIMIZATION
-- âŒ Slow for large tables
SELECT COUNT(*) FROM orders;

-- âœ… Use covering index
SELECT COUNT(id) FROM orders;

-- âœ… Approximate count (if exact not needed)
SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME = 'orders';


-- 5. JOIN ORDER
-- Optimizer usually handles this, but hint if needed
SELECT /*+ JOIN_ORDER(small_table, large_table) */ *
FROM small_table s
JOIN large_table l ON s.id = l.small_id;


-- 6. EXISTS vs IN
-- âŒ IN with large subquery
SELECT * FROM users WHERE id IN (SELECT user_id FROM orders);

-- âœ… EXISTS (short-circuits)
SELECT * FROM users u 
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);


-- 7. UNION ALL instead of UNION (when no duplicates)
-- âŒ UNION (sorts to remove dups)
SELECT name FROM customers UNION SELECT name FROM suppliers;

-- âœ… UNION ALL (no sort)
SELECT 'customer' AS type, name FROM customers
UNION ALL
SELECT 'supplier', name FROM suppliers;


-- 8. BATCH OPERATIONS
-- âŒ Row by row
UPDATE orders SET status = 'ARCHIVED' WHERE created_at < '2020-01-01';

-- âœ… Batch with LIMIT
WHILE (affected > 0) {
    UPDATE orders SET status = 'ARCHIVED' 
    WHERE created_at < '2020-01-01' AND status != 'ARCHIVED'
    LIMIT 10000;
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ANTI-PATTERNS -->
            <section class="content-section">
                <h2 id="antipatterns" class="section-title"><span class="section-icon">ğŸš«</span>Anti-Patterns</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Index-Killing Patterns</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Patterns
                                    That Prevent Index Use</span></div>
                            <pre><code class="language-sql">-- 1. FUNCTION ON INDEXED COLUMN
-- âŒ Function prevents index use
SELECT * FROM users WHERE YEAR(created_at) = 2024;
SELECT * FROM orders WHERE DATE(created_at) = '2024-01-01';

-- âœ… Range on column directly
SELECT * FROM users WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';
SELECT * FROM orders WHERE created_at >= '2024-01-01' AND created_at < '2024-01-02';


-- 2. IMPLICIT TYPE CONVERSION
-- âŒ phone is VARCHAR, comparing to INT
SELECT * FROM users WHERE phone = 84123456789;

-- âœ… Correct type
SELECT * FROM users WHERE phone = '84123456789';


-- 3. LEADING WILDCARD
-- âŒ Leading wildcard = full scan
SELECT * FROM products WHERE name LIKE '%phone%';

-- âœ… Trailing wildcard OK
SELECT * FROM products WHERE name LIKE 'iphone%';

-- âœ… Fulltext for text search
CREATE FULLTEXT INDEX idx_ft ON products(name);
SELECT * FROM products WHERE MATCH(name) AGAINST('phone');


-- 4. OR CONDITIONS (sometimes)
-- âŒ OR on different columns may not use index well
SELECT * FROM orders WHERE user_id = 1 OR status = 'PENDING';

-- âœ… UNION approach
SELECT * FROM orders WHERE user_id = 1
UNION
SELECT * FROM orders WHERE status = 'PENDING';


-- 5. NOT EQUAL / NOT IN
-- âŒ Negative conditions often skip index
SELECT * FROM users WHERE status != 'INACTIVE';
SELECT * FROM orders WHERE status NOT IN ('CANCELLED', 'REFUNDED');

-- âœ… Positive condition if possible
SELECT * FROM users WHERE status IN ('ACTIVE', 'PENDING');


-- 6. NULL COMPARISONS
-- âŒ May not use index efficiently
SELECT * FROM users WHERE phone IS NOT NULL;

-- Consider: Add default value instead of NULL


-- 7. SORTING WITHOUT INDEX
-- âŒ filesort needed
SELECT * FROM orders ORDER BY created_at DESC, amount ASC;

-- âœ… Index that matches ORDER BY
CREATE INDEX idx_order_sort ON orders(created_at DESC, amount ASC);</code></pre>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> Key Rules</h4>
                            <ul>
                                <li><strong>No functions on indexed columns:</strong> Move to other side of equation
                                </li>
                                <li><strong>Match data types:</strong> Implicit conversion kills index</li>
                                <li><strong>Leading wildcard:</strong> Use fulltext instead</li>
                                <li><strong>Check EXPLAIN:</strong> Verify index is actually used</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- INDEX MAINTENANCE -->
            <section class="content-section">
                <h2 id="maintenance" class="section-title"><span class="section-icon">ğŸ”§</span>Index Maintenance</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Monitoring & Maintenance</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Index
                                    Statistics & Maintenance</span></div>
                            <pre><code class="language-sql">-- View index statistics
SHOW INDEX FROM users;

-- Index size
SELECT 
    table_name,
    index_name,
    ROUND(stat_value * @@innodb_page_size / 1024 / 1024, 2) AS size_mb
FROM mysql.innodb_index_stats
WHERE stat_name = 'size' AND database_name = 'mydb';

-- Unused indexes (MySQL 8.0+)
SELECT 
    object_schema,
    object_name,
    index_name
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE index_name IS NOT NULL
  AND count_star = 0
  AND object_schema = 'mydb';

-- Rebuild/Optimize index
OPTIMIZE TABLE users;  -- Rebuilds table and indexes
ALTER TABLE users ENGINE=InnoDB;  -- Force rebuild

-- Analyze table (update statistics)
ANALYZE TABLE users;

-- Check index fragmentation
SELECT 
    table_name,
    data_length,
    index_length,
    ROUND((data_free / (data_length + index_length)) * 100, 2) AS fragmentation_pct
FROM information_schema.tables
WHERE table_schema = 'mydb';

-- Check cardinality (selectivity)
SELECT 
    INDEX_NAME,
    COLUMN_NAME,
    CARDINALITY,
    (CARDINALITY / (SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES 
                    WHERE TABLE_NAME = 'users')) AS selectivity
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_NAME = 'users';</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- INTERVIEW QUESTIONS -->
            <section id="interview" class="content-section">
                <h2 class="section-title"><span class="section-icon">ğŸ’¼</span>CÃ¢u Há»i Phá»ng Váº¥n</h2>

                <div class="interview-questions">
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q1</span>
                            <p>B-Tree index hoáº¡t Ä‘á»™ng nhÆ° tháº¿ nÃ o?</p>
                        </div>
                        <div class="answer">
                            <p>B-Tree lÃ  balanced tree vá»›i cÃ¡c nodes chá»©a keys sorted. Root/branch nodes chá»©a pointers,
                                leaf nodes chá»©a data/PK pointers vÃ  linked together. Lookup = O(log n), thÆ°á»ng 3-4 disk
                                reads cho millions rows. InnoDB dÃ¹ng B+Tree (leaves linked for range scans).</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q2</span>
                            <p>Clustered vs Non-Clustered Index?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>Clustered (PK):</strong> 1 per table, leaves = actual row data, table
                                    physically ordered by PK</li>
                                <li><strong>Non-Clustered:</strong> Multiple allowed, leaves = PK pointer, requires
                                    additional lookup</li>
                            </ul>
                            <p>InnoDB PK = clustered. Secondary index lookup: Index â†’ PK â†’ Row.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q3</span>
                            <p>Leftmost Prefix Rule lÃ  gÃ¬?</p>
                        </div>
                        <div class="answer">
                            <p>Composite index (a,b,c) chá»‰ dÃ¹ng Ä‘Æ°á»£c khi query báº¯t Ä‘áº§u tá»« leftmost columns. Queries on
                                (a), (a,b), (a,b,c) dÃ¹ng index. Query chá»‰ cÃ³ (b) hoáº·c (c) khÃ´ng dÃ¹ng Ä‘Æ°á»£c index. Range
                                condition "breaks" index cho columns sau.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q4</span>
                            <p>Covering Index lÃ  gÃ¬?</p>
                        </div>
                        <div class="answer">
                            <p>Index chá»©a táº¥t cáº£ columns cáº§n cho query â†’ khÃ´ng cáº§n table lookup. EXPLAIN shows "Using
                                index" in Extra. Trade-off: larger index size, higher write overhead. Best for
                                frequently run queries with specific column needs.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q5</span>
                            <p>Khi nÃ o index KHÃ”NG Ä‘Æ°á»£c sá»­ dá»¥ng?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li>Function on column: <code>WHERE YEAR(date) = 2024</code></li>
                                <li>Implicit type conversion</li>
                                <li>Leading wildcard: <code>LIKE '%abc'</code></li>
                                <li>NOT IN, != (sometimes)</li>
                                <li>OR on different columns</li>
                                <li>Small table (optimizer chá»n full scan)</li>
                            </ul>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q6</span>
                            <p>EXPLAIN type column: ref vs range vs ALL?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>ref:</strong> Non-unique index lookup (good)</li>
                                <li><strong>range:</strong> Range scan with index (>, <, BETWEEN) (OK)</li>
                                <li><strong>ALL:</strong> Full table scan (bad - no index used)</li>
                            </ul>
                            <p>Best to worst: const â†’ eq_ref â†’ ref â†’ range â†’ index â†’ ALL</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q7</span>
                            <p>LÃ m sao optimize pagination cho large offset?</p>
                        </div>
                        <div class="answer">
                            <pre><code class="language-sql">-- âŒ Slow: LIMIT 10 OFFSET 100000 (scans 100010 rows)
-- âœ… Keyset pagination:
SELECT * FROM users WHERE id > :last_id ORDER BY id LIMIT 10;</code></pre>
                            <p>Keyset pagination uses index seek instead of offset scan.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q8</span>
                            <p>Index design considerations?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>Query patterns:</strong> Design based on WHERE, JOIN, ORDER BY</li>
                                <li><strong>Cardinality:</strong> High selectivity columns first</li>
                                <li><strong>Write overhead:</strong> More indexes = slower INSERTs</li>
                                <li><strong>Storage:</strong> Index cÃ³ thá»ƒ = 10-30% table size</li>
                                <li><strong>Composite:</strong> Equality before range, covering if possible</li>
                            </ul>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q9</span>
                            <p>Fulltext index khi nÃ o dÃ¹ng?</p>
                        </div>
                        <div class="answer">
                            <p>DÃ¹ng cho text search trong large text fields (articles, descriptions). Supports natural
                                language search vÃ  boolean mode (+word -word). Better than LIKE '%word%' because: (1)
                                Uses inverted index, (2) Relevance scoring, (3) Word stemming. KhÃ´ng thay tháº¿
                                Elasticsearch cho complex search.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q10</span>
                            <p>UUID vs Auto-increment cho Primary Key?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>Auto-increment:</strong> Sequential â†’ good insert performance, smaller size
                                    (8 bytes), predictable</li>
                                <li><strong>UUID:</strong> Random â†’ page splits, larger (36 bytes), distributed
                                    generation OK</li>
                            </ul>
                            <p>Auto-increment tá»‘t hÆ¡n cho performance. UUID cáº§n cho distributed systems. MySQL 8.0+ cÃ³
                                UUID_TO_BIN() Ä‘á»ƒ improve storage.</p>
                        </div>
                    </div>
                </div>
            </section>

            <div class="page-navigation">
                <a href="sql-fundamentals.html" class="nav-btn prev"><i class="fas fa-arrow-left"></i><span>SQL
                        Fundamentals</span></a>
                <a href="transactions.html" class="nav-btn next"><span>Transactions</span><i
                        class="fas fa-arrow-right"></i></a>
            </div>
        </article>
    </main>

    <button class="back-to-top" id="backToTop"><i class="fas fa-arrow-up"></i></button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="../js/main.js"></script>
</body>

</html>