<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indexing & Performance - MySQL Interview</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="bg-animation"></div>

    <nav class="top-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-logo"><i class="fas fa-rocket"></i><span>Interview Hub</span></a>
            <a href="../index.html#mysql" class="nav-back"><i class="fas fa-arrow-left"></i> MySQL</a>
        </div>
    </nav>

    <header class="topic-header">
        <div class="topic-icon mysql"><i class="fas fa-search"></i></div>
        <div class="topic-info">
            <span class="topic-category">MySQL</span>
            <h1>Indexing & Performance</h1>
            <p class="topic-desc">B-Tree, Index Types, EXPLAIN, Query Optimization</p>
        </div>
    </header>

    <main class="content-container">
        <aside class="toc">
            <h3><i class="fas fa-list"></i> Ná»™i dung</h3>
            <ul>
                <li><a href="#how-index">How Indexes Work</a></li>
                <li><a href="#types">Index Types</a></li>
                <li><a href="#composite">Composite Indexes</a></li>
                <li><a href="#explain">EXPLAIN & Analysis</a></li>
                <li><a href="#optimization">Query Optimization</a></li>
                <li><a href="#antipatterns">Anti-Patterns</a></li>
                <li><a href="#interview">CÃ¢u há»i phá»ng váº¥n</a></li>
            </ul>
        </aside>

        <article class="main-content">
            <section class="content-section">
                <h2 id="how-index" class="section-title"><span class="section-icon">ğŸŒ³</span>How Indexes Work</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>B-Tree Index</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Structure</span></div>
                            <pre><code>B-Tree Index (Balanced Tree)
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  [50, 100, 150] â”‚  Root
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼                 â–¼                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚[10,25,40] â”‚     â”‚[60,75,90] â”‚     â”‚[110,130]  â”‚  Branch
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â–¼                 â–¼                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Leaf     â”‚  â†’   â”‚ Leaf     â”‚  â†’   â”‚ Leaf     â”‚  Leaf (linked)
    â”‚ Data Ptr â”‚      â”‚ Data Ptr â”‚      â”‚ Data Ptr â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Without Index: Full table scan O(n)
With B-Tree:   O(log n) lookups</code></pre>
                        </div>

                        <div class="key-points">
                            <h4><i class="fas fa-check-circle"></i> Index Benefits</h4>
                            <ul>
                                <li><strong>Faster WHERE:</strong> Binary search instead of full scan</li>
                                <li><strong>Faster ORDER BY:</strong> Data already sorted</li>
                                <li><strong>Faster JOIN:</strong> Quick lookup of matching rows</li>
                                <li><strong>Covering index:</strong> All data in index, no table access needed</li>
                            </ul>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> Index Costs</h4>
                            <ul>
                                <li>Slower INSERT/UPDATE/DELETE (must update index)</li>
                                <li>Storage space</li>
                                <li>Too many indexes = maintenance overhead</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2 id="types" class="section-title"><span class="section-icon">ğŸ“‘</span>Index Types</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>MySQL Index Types</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="comparison-table">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>PRIMARY KEY</strong></td>
                                        <td>Unique, not null, clustered</td>
                                        <td>Record identifier</td>
                                    </tr>
                                    <tr>
                                        <td><strong>UNIQUE</strong></td>
                                        <td>Unique values allowed</td>
                                        <td>Email, username</td>
                                    </tr>
                                    <tr>
                                        <td><strong>INDEX / KEY</strong></td>
                                        <td>Regular B-Tree index</td>
                                        <td>Frequent WHERE/JOIN columns</td>
                                    </tr>
                                    <tr>
                                        <td><strong>FULLTEXT</strong></td>
                                        <td>Text search</td>
                                        <td>Search in text content</td>
                                    </tr>
                                    <tr>
                                        <td><strong>SPATIAL</strong></td>
                                        <td>Geometric data</td>
                                        <td>GIS applications</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Creating
                                    Indexes</span></div>
                            <pre><code>-- Create index on existing table
CREATE INDEX idx_users_email ON users(email);
CREATE UNIQUE INDEX idx_users_email ON users(email);

-- Create with table
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    name VARCHAR(100),
    status VARCHAR(20),
    created_at DATETIME,
    
    INDEX idx_status (status),
    INDEX idx_created (created_at)
);

-- Composite index
CREATE INDEX idx_status_created ON users(status, created_at);

-- Prefix index for long text
CREATE INDEX idx_name ON users(name(20));  -- First 20 chars only

-- FULLTEXT for text search
CREATE FULLTEXT INDEX idx_content ON articles(title, content);
SELECT * FROM articles WHERE MATCH(title, content) AGAINST('keyword');

-- View indexes
SHOW INDEX FROM users;

-- Drop index
DROP INDEX idx_users_email ON users;
ALTER TABLE users DROP INDEX idx_users_email;</code></pre>
                        </div>

                        <div class="info-box">
                            <h4><i class="fas fa-info-circle"></i> Clustered vs Secondary Index</h4>
                            <ul>
                                <li><strong>Clustered (PRIMARY KEY):</strong> Rows stored in PK order. Only one per
                                    table. InnoDB uses PK as clustered.</li>
                                <li><strong>Secondary:</strong> Separate structure, stores PK value as pointer. Need
                                    extra lookup to get row data.</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2 id="composite" class="section-title"><span class="section-icon">ğŸ”¢</span>Composite Indexes</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Multi-Column Indexes</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Concept</span></div>
                            <pre><code>Index on (status, created_at, user_id)

Leftmost prefix rule - Index used for:
âœ… WHERE status = 'ACTIVE'
âœ… WHERE status = 'ACTIVE' AND created_at > '2024-01-01'
âœ… WHERE status = 'ACTIVE' AND created_at > '2024-01-01' AND user_id = 1

âŒ WHERE created_at > '2024-01-01'  -- Skipped status!
âŒ WHERE user_id = 1                -- Skipped status and created_at!</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Composite Index Design</span></div>
                            <pre><code>-- Query pattern:
-- SELECT * FROM orders WHERE user_id = ? AND status = ? ORDER BY created_at DESC

-- Good composite index:
CREATE INDEX idx_user_status_created ON orders(user_id, status, created_at);

-- Order matters! Consider:
-- 1. Equality conditions first (user_id, status)
-- 2. Range/ORDER BY column last (created_at)

-- SELECT * FROM orders WHERE user_id = 123 AND status = 'PENDING' ORDER BY created_at
-- Uses full index: (user_id=123, status='PENDING', ORDER BY created_at)


-- Bad: Range before ORDER BY
CREATE INDEX idx_bad ON orders(user_id, created_at, status);
-- WHERE user_id = 123 AND created_at > '2024-01-01' AND status = 'PENDING'
-- Can only use user_id and created_at, status needs filesort</code></pre>
                        </div>

                        <div class="key-points">
                            <h4><i class="fas fa-lightbulb"></i> Index Design Rules</h4>
                            <ul>
                                <li><strong>Equality first:</strong> Columns with = conditions leftmost</li>
                                <li><strong>Range/ORDER BY last:</strong> Put range/sort columns at end</li>
                                <li><strong>High cardinality:</strong> Selective columns (many unique values) benefit
                                    more</li>
                                <li><strong>Cover if possible:</strong> Include SELECT columns to avoid table lookup
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2 id="explain" class="section-title"><span class="section-icon">ğŸ”</span>EXPLAIN & Analysis</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Query Execution Plan</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">EXPLAIN
                                    Output</span></div>
                            <pre><code>EXPLAIN SELECT * FROM users WHERE email = 'john@example.com';

+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+
| 1  | SIMPLE      | users | ref  | idx_email     |idx...|  767    | const| 1    | Using index |
+----+-------------+-------+------+---------------+------+---------+------+------+-------------+

EXPLAIN FORMAT=JSON SELECT ...;  -- Detailed JSON output
EXPLAIN ANALYZE SELECT ...;      -- Actually run and show timing (MySQL 8.0.18+)</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>EXPLAIN type Column (best to worst)</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Performance</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>system</code></td>
                                        <td>Table has 1 row</td>
                                        <td>ğŸŸ¢ Best</td>
                                    </tr>
                                    <tr>
                                        <td><code>const</code></td>
                                        <td>PK or unique index, 1 row</td>
                                        <td>ğŸŸ¢ Excellent</td>
                                    </tr>
                                    <tr>
                                        <td><code>eq_ref</code></td>
                                        <td>1 row per join (unique index)</td>
                                        <td>ğŸŸ¢ Very Good</td>
                                    </tr>
                                    <tr>
                                        <td><code>ref</code></td>
                                        <td>Non-unique index lookup</td>
                                        <td>ğŸŸ¡ Good</td>
                                    </tr>
                                    <tr>
                                        <td><code>range</code></td>
                                        <td>Index range scan</td>
                                        <td>ğŸŸ¡ OK</td>
                                    </tr>
                                    <tr>
                                        <td><code>index</code></td>
                                        <td>Full index scan</td>
                                        <td>ğŸŸ  Slow</td>
                                    </tr>
                                    <tr>
                                        <td><code>ALL</code></td>
                                        <td>Full table scan</td>
                                        <td>ğŸ”´ Worst</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Extra
                                    Column Keywords</span></div>
                            <pre><code>Extra column meanings:

âœ… Using index         -- Covered by index (no table access)
âœ… Using where         -- WHERE filtering applied
ğŸŸ¡ Using temporary     -- Temp table needed (may be slow)
ğŸŸ¡ Using filesort      -- Extra sort pass needed
ğŸ”´ Using filesort      -- Sort not using index
ğŸ”´ Full scan on NULL key -- Subquery issue</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2 id="optimization" class="section-title"><span class="section-icon">âš¡</span>Query Optimization</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Performance Tips</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Optimization Examples</span></div>
                            <pre><code>-- âŒ Bad: Function on indexed column
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- âœ… Good: Range query
SELECT * FROM users WHERE created_at >= '2024-01-01' 
                      AND created_at < '2025-01-01';


-- âŒ Bad: Leading wildcard
SELECT * FROM users WHERE name LIKE '%john%';

-- âœ… OK: Trailing wildcard can use index
SELECT * FROM users WHERE name LIKE 'john%';


-- âŒ Bad: Type mismatch
SELECT * FROM users WHERE phone = 84123456789;  -- phone is VARCHAR

-- âœ… Good: Correct type
SELECT * FROM users WHERE phone = '84123456789';


-- âŒ Bad: OR can prevent index usage
SELECT * FROM users WHERE email = 'a@b.com' OR name = 'John';

-- âœ… Good: UNION for different indexes
SELECT * FROM users WHERE email = 'a@b.com'
UNION
SELECT * FROM users WHERE name = 'John';


-- âŒ Bad: SELECT *
SELECT * FROM users WHERE status = 'ACTIVE';

-- âœ… Good: Select needed columns (can use covering index)
SELECT id, name, email FROM users WHERE status = 'ACTIVE';


-- Pagination optimization
-- âŒ Bad: Large OFFSET
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 100000;

-- âœ… Good: Seek method (remember last id)
SELECT * FROM users WHERE id > 100000 ORDER BY id LIMIT 10;</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section class="content-section">
                <h2 id="antipatterns" class="section-title"><span class="section-icon">ğŸš«</span>Indexing Anti-Patterns
                </h2>

                <div class="concept-card">
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Examples</span><span
                                    class="code-title">What NOT to do</span></div>
                            <pre><code>-- âŒ Too many indexes
-- Each index = storage + slower writes
-- Only index columns used in WHERE, JOIN, ORDER BY

-- âŒ Index on low cardinality columns
CREATE INDEX idx_gender ON users(gender);  -- Only M/F values
-- Better as part of composite index or skip

-- âŒ Redundant indexes  
CREATE INDEX idx_a ON users(a);
CREATE INDEX idx_ab ON users(a, b);  -- idx_a is redundant!

-- âŒ Index every column in WHERE
-- WHERE a = 1 AND b = 2 AND c = 3
-- One good composite index (a, b, c) beats 3 single indexes

-- âŒ Forgetting to analyze after bulk changes
ANALYZE TABLE users;  -- Update statistics for optimizer

-- âŒ Not using covering indexes when possible
-- If query only needs id, name from large table:
CREATE INDEX idx_name_covering ON users(name, id);
SELECT id, name FROM users WHERE name LIKE 'John%';
-- All data from index, no table access!</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <section id="interview" class="content-section">
                <h2 class="section-title"><span class="section-icon">ğŸ’¼</span>CÃ¢u Há»i Phá»ng Váº¥n</h2>

                <div class="interview-questions">
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q1</span>
                            <p>How does B-Tree index work?</p>
                        </div>
                        <div class="answer">
                            <p>Balanced tree structure. Sorted keys in nodes, O(log n) lookup. Leaf nodes linked for
                                range scans. InnoDB uses B+Tree where all data in leaves.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q2</span>
                            <p>What is Clustered vs Secondary index?</p>
                        </div>
                        <div class="answer">
                            <p><strong>Clustered:</strong> Data stored in index order (PK in InnoDB), one per table.
                                <strong>Secondary:</strong> Separate structure, stores PK pointer, needs extra lookup
                                for full row.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q3</span>
                            <p>What is Covering Index?</p>
                        </div>
                        <div class="answer">
                            <p>Index contains all columns needed by query. No table lookup required. Shows "Using index"
                                in EXPLAIN. Design indexes to cover frequent queries.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q4</span>
                            <p>How to optimize slow query?</p>
                        </div>
                        <div class="answer">
                            <p>1) EXPLAIN to see execution plan. 2) Check type (avoid ALL). 3) Add missing indexes. 4)
                                Avoid functions on indexed columns. 5) Consider covering index. 6) Check for type
                                mismatches.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q5</span>
                            <p>What is Leftmost Prefix Rule?</p>
                        </div>
                        <div class="answer">
                            <p>Composite index (a,b,c) can be used for: (a), (a,b), (a,b,c). Cannot skip columns: (b,c)
                                or (c) won't use index. Order matters!</p>
                        </div>
                    </div>
                </div>
            </section>

            <div class="page-navigation">
                <a href="sql-fundamentals.html" class="nav-btn prev"><i class="fas fa-arrow-left"></i><span>SQL
                        Fundamentals</span></a>
                <a href="transactions.html" class="nav-btn next"><span>Transactions</span><i
                        class="fas fa-arrow-right"></i></a>
            </div>
        </article>
    </main>

    <button class="back-to-top" id="backToTop"><i class="fas fa-arrow-up"></i></button>
    <script src="../js/main.js"></script>
</body>

</html>