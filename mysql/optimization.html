<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Query Optimization - MySQL Interview</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="bg-animation"></div>

    <nav class="top-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-logo"><i class="fas fa-rocket"></i><span>Interview Hub</span></a>
            <a href="transactions.html" class="nav-back"><i class="fas fa-arrow-left"></i> Transactions</a>
        </div>
    </nav>

    <header class="topic-header">
        <div class="topic-icon mysql"><i class="fas fa-tachometer-alt"></i></div>
        <div class="topic-info">
            <span class="topic-category">MySQL</span>
            <h1>Query Optimization</h1>
            <p class="topic-desc">Slow Query Log, Profiling, Query Tuning, Performance Best Practices</p>
        </div>
    </header>

    <main class="content-container">
        <aside class="toc">
            <h3><i class="fas fa-list"></i> N·ªôi dung</h3>
            <ul>
                <li><a href="#slow-query">Slow Query Log</a></li>
                <li><a href="#profiling">Query Profiling</a></li>
                <li><a href="#tuning">Query Tuning</a></li>
                <li><a href="#join-optimization">JOIN Optimization</a></li>
                <li><a href="#pagination">Pagination</a></li>
                <li><a href="#caching">Query Caching</a></li>
                <li><a href="#configuration">Server Configuration</a></li>
                <li><a href="#interview">C√¢u h·ªèi ph·ªèng v·∫•n</a></li>
            </ul>
        </aside>

        <article class="main-content">
            <!-- SLOW QUERY LOG -->
            <section class="content-section">
                <h2 id="slow-query" class="section-title"><span class="section-icon">üêå</span>Slow Query Log</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Enable & Analyze</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Slow
                                    Query Log Configuration</span></div>
                            <pre><code class="language-sql">-- Check current settings
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';
SHOW VARIABLES LIKE 'log_queries_not_using_indexes';

-- Enable slow query log
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;  -- Log queries > 1 second
SET GLOBAL log_queries_not_using_indexes = 'ON';  -- Log queries without index

-- Check log file location
SHOW VARIABLES LIKE 'slow_query_log_file';

-- In my.cnf (permanent)
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 1
log_queries_not_using_indexes = 1
min_examined_row_limit = 100  -- Only log if > 100 rows examined</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Bash</span><span class="code-title">Analyze
                                    Slow Query Log</span></div>
                            <pre><code class="language-bash"># MySQL built-in tool
mysqldumpslow -s t /var/log/mysql/slow.log  # Sort by time
mysqldumpslow -s c /var/log/mysql/slow.log  # Sort by count
mysqldumpslow -s l /var/log/mysql/slow.log  # Sort by lock time
mysqldumpslow -t 10 /var/log/mysql/slow.log # Top 10

# pt-query-digest (more powerful - Percona Toolkit)
pt-query-digest /var/log/mysql/slow.log
pt-query-digest --since '24h' /var/log/mysql/slow.log
pt-query-digest --filter '$event->{Query_time} > 5' slow.log</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- QUERY PROFILING -->
            <section class="content-section">
                <h2 id="profiling" class="section-title"><span class="section-icon">üìä</span>Query Profiling</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Performance Schema & Profiling</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">EXPLAIN
                                    ANALYZE</span></div>
                            <pre><code class="language-sql">-- EXPLAIN ANALYZE (MySQL 8.0.18+)
EXPLAIN ANALYZE SELECT * FROM orders 
WHERE user_id = 123 AND status = 'ACTIVE';

/* Output:
-> Filter: ((orders.`status` = 'ACTIVE') and (orders.user_id = 123))  
   (cost=1.16 rows=1) (actual time=0.089..0.112 rows=1 loops=1)
    -> Index lookup on orders using idx_user_status 
       (user_id=123, status='ACTIVE')  (cost=1.16 rows=1) 
       (actual time=0.087..0.109 rows=1 loops=1)

Key metrics:
‚Ä¢ cost: Optimizer's estimated cost
‚Ä¢ rows: Estimated row count  
‚Ä¢ actual time: first_row..last_row (milliseconds)
‚Ä¢ loops: How many times executed
*/</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Session
                                    Status Counters</span></div>
                            <pre><code class="language-sql">-- Reset counters
FLUSH STATUS;

-- Run your query
SELECT * FROM orders WHERE user_id = 123;

-- Check key metrics
SHOW SESSION STATUS LIKE 'Handler%';
SHOW SESSION STATUS LIKE 'Created_tmp%';
SHOW SESSION STATUS LIKE 'Sort%';

/*
Key indicators:
Handler_read_rnd_next  ‚Üí Full table scans (high = bad)
Handler_read_key       ‚Üí Index lookups (good)
Handler_read_next      ‚Üí Index range scans (good)
Created_tmp_tables     ‚Üí Temp tables used
Created_tmp_disk_tables ‚Üí Disk temp tables (bad!)
Sort_merge_passes      ‚Üí Sort needed multiple passes
*/

-- Performance Schema queries
SELECT * FROM performance_schema.events_statements_summary_by_digest
ORDER BY sum_timer_wait DESC LIMIT 10;

-- Find queries with full table scans
SELECT * FROM performance_schema.events_statements_history
WHERE ROWS_EXAMINED > ROWS_SENT * 10;  -- Examined 10x more than returned</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Query
                                    Profiling (Legacy)</span></div>
                            <pre><code class="language-sql">-- Enable profiling (deprecated but still useful)
SET profiling = 1;

-- Run query
SELECT * FROM large_table WHERE status = 'ACTIVE';

-- Show profile
SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;
SHOW PROFILE CPU, BLOCK IO FOR QUERY 1;

/*
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000024 |
| checking permissions | 0.000008 |
| Opening tables       | 0.000018 |
| init                 | 0.000021 |
| optimizing           | 0.000012 |
| executing            | 0.000090 |
| Sending data         | 0.523156 | ‚Üê Most time spent here
| end                  | 0.000012 |
+----------------------+----------+
*/</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- QUERY TUNING -->
            <section class="content-section">
                <h2 id="tuning" class="section-title"><span class="section-icon">üîß</span>Query Tuning</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Common Optimizations</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Index-Killing Patterns</span></div>
                            <pre><code class="language-sql">-- ‚ùå Function on indexed column
SELECT * FROM users WHERE YEAR(created_at) = 2024;

-- ‚úÖ Range condition instead
SELECT * FROM users 
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';


-- ‚ùå Implicit type conversion (phone is VARCHAR)
SELECT * FROM users WHERE phone = 84123456789;

-- ‚úÖ Correct type
SELECT * FROM users WHERE phone = '84123456789';


-- ‚ùå Leading wildcard
SELECT * FROM products WHERE name LIKE '%phone%';

-- ‚úÖ Trailing wildcard (can use index)
SELECT * FROM products WHERE name LIKE 'iPhone%';

-- ‚úÖ Fulltext for text search
CREATE FULLTEXT INDEX idx_ft_name ON products(name);
SELECT * FROM products WHERE MATCH(name) AGAINST('phone');


-- ‚ùå OR can prevent single index use
SELECT * FROM orders WHERE user_id = 1 OR status = 'PENDING';

-- ‚úÖ UNION approach (each uses its own index)
SELECT * FROM orders WHERE user_id = 1
UNION
SELECT * FROM orders WHERE status = 'PENDING' AND user_id != 1;</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Efficient Query Patterns</span></div>
                            <pre><code class="language-sql">-- ‚ùå SELECT * (fetches unnecessary columns)
SELECT * FROM users WHERE status = 'ACTIVE';

-- ‚úÖ Select only needed columns (may use covering index)
SELECT id, name, email FROM users WHERE status = 'ACTIVE';


-- ‚ùå COUNT(*) on large tables
SELECT COUNT(*) FROM orders;

-- ‚úÖ Approximate count (if exact not needed)
SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME = 'orders';

-- ‚úÖ Or use COUNT on indexed column
SELECT COUNT(id) FROM orders;


-- ‚ùå Check existence with COUNT
IF (SELECT COUNT(*) FROM users WHERE email = ?) > 0 THEN...

-- ‚úÖ Use EXISTS (stops at first match)
IF EXISTS (SELECT 1 FROM users WHERE email = ?) THEN...


-- ‚ùå DISTINCT with many columns
SELECT DISTINCT category, brand, color FROM products;

-- ‚úÖ GROUP BY (often more efficient)
SELECT category, brand, color FROM products 
GROUP BY category, brand, color;


-- ‚ùå NOT IN with subquery (NULL issues + performance)
SELECT * FROM users WHERE id NOT IN (SELECT user_id FROM banned);

-- ‚úÖ LEFT JOIN + IS NULL
SELECT u.* FROM users u
LEFT JOIN banned b ON u.id = b.user_id
WHERE b.user_id IS NULL;

-- ‚úÖ NOT EXISTS
SELECT * FROM users u
WHERE NOT EXISTS (SELECT 1 FROM banned b WHERE b.user_id = u.id);</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- JOIN OPTIMIZATION -->
            <section class="content-section">
                <h2 id="join-optimization" class="section-title"><span class="section-icon">üîó</span>JOIN Optimization
                </h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>JOIN Performance</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">JOIN
                                    Best Practices</span></div>
                            <pre><code class="language-sql">-- 1. Index JOIN columns
-- Ensure foreign keys and JOIN columns have indexes
CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_items_order ON order_items(order_id);


-- 2. Start from smaller table (optimizer usually handles this)
SELECT * FROM categories c  -- Small table
JOIN products p ON c.id = p.category_id;  -- Large table


-- 3. Filter early (push WHERE to reduce rows)
-- ‚ùå Filter after JOIN
SELECT * FROM users u
JOIN orders o ON u.id = o.user_id
WHERE u.status = 'ACTIVE';

-- ‚úÖ Filter in subquery (sometimes faster)
SELECT * FROM (
    SELECT * FROM users WHERE status = 'ACTIVE'
) AS active_users
JOIN orders o ON active_users.id = o.user_id;


-- 4. Avoid functions on JOIN columns
-- ‚ùå Date conversion prevents index
SELECT * FROM a JOIN b ON DATE(a.created_at) = DATE(b.created_at);

-- ‚úÖ Store as DATE or compare ranges
SELECT * FROM a JOIN b 
ON a.created_at >= b.created_at 
AND a.created_at < DATE_ADD(b.created_at, INTERVAL 1 DAY);


-- 5. Use covering indexes for JOIN
CREATE INDEX idx_covering ON orders(user_id, total, status);
SELECT o.user_id, o.total, o.status  -- All in index
FROM users u
JOIN orders o ON u.id = o.user_id;


-- 6. Subquery vs JOIN
-- JOIN usually faster for simple lookups
-- Subquery may be better for complex aggregations

-- ‚ùå Correlated subquery (runs for each row)
SELECT name, (SELECT SUM(amount) FROM orders o WHERE o.user_id = u.id) as total
FROM users u;

-- ‚úÖ JOIN with GROUP BY
SELECT u.name, COALESCE(SUM(o.amount), 0) as total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- PAGINATION -->
            <section class="content-section">
                <h2 id="pagination" class="section-title"><span class="section-icon">üìÑ</span>Pagination</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Efficient Pagination</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Pagination Methods</span></div>
                            <pre><code class="language-sql">-- ‚ùå OFFSET pagination (slow for large offset)
-- MySQL still scans and discards OFFSET rows
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 100000;
-- Scans 100,010 rows to return 10!


-- ‚úÖ Keyset/Cursor pagination (much faster)
-- Use last seen value instead of OFFSET
SELECT * FROM users WHERE id > 100000 ORDER BY id LIMIT 10;
-- Uses index seek, very fast!


-- ‚úÖ Keyset with multiple columns
SELECT * FROM posts 
WHERE (created_at, id) > ('2024-01-15 10:00:00', 12345)
ORDER BY created_at DESC, id DESC
LIMIT 10;


-- ‚ö†Ô∏è Deferred JOIN (optimization for SELECT *)
-- First get only IDs with offset, then JOIN for full data
SELECT * FROM users
INNER JOIN (
    SELECT id FROM users ORDER BY created_at DESC LIMIT 10 OFFSET 100000
) AS page ON users.id = page.id
ORDER BY users.created_at DESC;
-- Faster because offset scan on smaller index-only query


-- ‚úÖ Count optimization
-- ‚ùå Expensive count each page
SELECT COUNT(*) FROM users WHERE status = 'ACTIVE';
SELECT * FROM users WHERE status = 'ACTIVE' LIMIT 10 OFFSET 0;

-- ‚úÖ Estimate total or limit max pages
SELECT TABLE_ROWS FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = 'users';
-- Or: only show "Page 1 of 50+" instead of exact count</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>Pagination Methods Comparison</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Method</th>
                                        <th>Performance</th>
                                        <th>Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>OFFSET</strong></td>
                                        <td>Degrades with offset</td>
                                        <td>Small datasets, admin UI</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Keyset</strong></td>
                                        <td>Consistent</td>
                                        <td>Infinite scroll, APIs</td>
                                    </tr>
                                    <tr>
                                        <td><strong>Deferred JOIN</strong></td>
                                        <td>Good for deep pages</td>
                                        <td>When keyset not possible</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- CACHING -->
            <section class="content-section">
                <h2 id="caching" class="section-title"><span class="section-icon">üíæ</span>Query Caching</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Caching Strategies</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">MySQL
                                    Query Cache (Deprecated)</span></div>
                            <pre><code class="language-sql">-- Note: Query Cache removed in MySQL 8.0!
-- In MySQL 5.7:
SHOW VARIABLES LIKE 'query_cache%';
SET GLOBAL query_cache_size = 67108864;  -- 64MB
SET GLOBAL query_cache_type = 1;

-- Why deprecated:
-- 1. Single mutex (concurrency bottleneck)
-- 2. Invalidated on any table write
-- 3. Memory fragmentation
-- 4. Doesn't scale well</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Pseudocode</span><span
                                    class="code-title">Application-Level Caching</span></div>
                            <pre><code>// Better approach: Application-level caching with Redis/Memcached

// 1. Cache-Aside Pattern
function getUserById(userId) {
    // Try cache first
    cached = redis.get(`user:${userId}`);
    if (cached) return JSON.parse(cached);
    
    // Cache miss - query database
    user = db.query("SELECT * FROM users WHERE id = ?", [userId]);
    
    // Store in cache with TTL
    redis.setex(`user:${userId}`, 3600, JSON.stringify(user));
    return user;
}

// 2. Write-Through Cache
function updateUser(userId, data) {
    // Update database
    db.query("UPDATE users SET ... WHERE id = ?", [data, userId]);
    
    // Update cache
    redis.setex(`user:${userId}`, 3600, JSON.stringify(data));
}

// 3. Cache Invalidation
function deleteUser(userId) {
    db.query("DELETE FROM users WHERE id = ?", [userId]);
    redis.del(`user:${userId}`);
    redis.del("users:list");  // Invalidate related caches
}</code></pre>
                        </div>

                        <div class="key-points">
                            <h4><i class="fas fa-key"></i> Caching Best Practices</h4>
                            <ul>
                                <li><strong>Cache hot data:</strong> Frequently accessed, rarely changed</li>
                                <li><strong>Use TTL:</strong> Prevent stale data, auto-expire</li>
                                <li><strong>Invalidate properly:</strong> Update/delete cache when data changes</li>
                                <li><strong>Monitor hit rate:</strong> Target > 90% for effective caching</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- SERVER CONFIGURATION -->
            <section class="content-section">
                <h2 id="configuration" class="section-title"><span class="section-icon">‚öôÔ∏è</span>Server Configuration
                </h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Key Performance Parameters</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">INI</span><span class="code-title">my.cnf
                                    Performance Tuning</span></div>
                            <pre><code>[mysqld]
# InnoDB Buffer Pool - Most important setting!
# Set to 70-80% of available RAM for dedicated server
innodb_buffer_pool_size = 12G

# Buffer pool instances (reduce contention)
innodb_buffer_pool_instances = 8

# Log file size (larger = better write performance, longer recovery)
innodb_log_file_size = 1G

# Flush method
innodb_flush_method = O_DIRECT

# Change buffer (for secondary index updates)
innodb_change_buffer_max_size = 25

# Thread concurrency
innodb_thread_concurrency = 0  # Auto

# Connection handling
max_connections = 500
thread_cache_size = 50

# Memory per connection
sort_buffer_size = 2M
join_buffer_size = 2M
read_buffer_size = 1M
tmp_table_size = 64M
max_heap_table_size = 64M

# Table cache
table_open_cache = 4000
table_definition_cache = 2000

# Slow query log
slow_query_log = 1
long_query_time = 1</code></pre>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Monitor
                                    Buffer Pool</span></div>
                            <pre><code class="language-sql">-- Buffer pool usage
SHOW ENGINE INNODB STATUS\G

-- Buffer pool hit rate (should be > 99%)
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool%';

-- Calculate hit rate
SELECT 
    (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100 
    AS buffer_pool_hit_rate
FROM (
    SELECT VARIABLE_VALUE AS Innodb_buffer_pool_reads
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads'
) a, (
    SELECT VARIABLE_VALUE AS Innodb_buffer_pool_read_requests
    FROM performance_schema.global_status 
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'
) b;</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- INTERVIEW QUESTIONS -->
            <section id="interview" class="content-section">
                <h2 class="section-title"><span class="section-icon">üíº</span>C√¢u H·ªèi Ph·ªèng V·∫•n</h2>

                <div class="interview-questions">
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q1</span>
                            <p>L√†m sao identify slow queries?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>Slow Query Log:</strong> Enable v·ªõi <code>long_query_time</code></li>
                                <li><strong>Performance Schema:</strong> events_statements_summary_by_digest</li>
                                <li><strong>EXPLAIN ANALYZE:</strong> Actual execution times</li>
                                <li><strong>pt-query-digest:</strong> Analyze v√† aggregate slow log</li>
                            </ul>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q2</span>
                            <p>EXPLAIN output quan tr·ªçng nh·∫•t?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>type:</strong> ALL (full scan) vs ref/const (index)</li>
                                <li><strong>key:</strong> Index ƒë∆∞·ª£c s·ª≠ d·ª•ng (NULL = no index)</li>
                                <li><strong>rows:</strong> Estimated rows scanned</li>
                                <li><strong>Extra:</strong> Using filesort, Using temporary (bad!)</li>
                            </ul>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q3</span>
                            <p>T·∫°i sao LIKE '%abc' ch·∫≠m?</p>
                        </div>
                        <div class="answer">
                            <p>Leading wildcard kh√¥ng th·ªÉ d√πng B-Tree index v√¨ index sorted by first character. Ph·∫£i
                                scan to√†n b·ªô index/table. Solution: Fulltext index, search engine (Elasticsearch), ho·∫∑c
                                reverse column technique.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q4</span>
                            <p>L√†m sao optimize large OFFSET pagination?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>Keyset pagination:</strong> WHERE id > :last_id ORDER BY id LIMIT 10</li>
                                <li><strong>Deferred JOIN:</strong> Get IDs first, then JOIN for full data</li>
                                <li><strong>Limit max pages:</strong> Ch·ªâ show "Page 1 of 100"</li>
                            </ul>
                            <p>OFFSET ph·∫£i scan v√† discard N rows ‚Üí O(N+limit).</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q5</span>
                            <p>COUNT(*) vs COUNT(column)?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>COUNT(*):</strong> ƒê·∫øm t·∫•t c·∫£ rows (k·ªÉ c·∫£ NULL)</li>
                                <li><strong>COUNT(column):</strong> ƒê·∫øm non-NULL values only</li>
                                <li><strong>COUNT(1):</strong> Same as COUNT(*)</li>
                            </ul>
                            <p>COUNT(*) c√≥ th·ªÉ d√πng covering index. V·ªõi InnoDB, COUNT(*) ph·∫£i scan to√†n b·ªô (kh√¥ng cache
                                nh∆∞ MyISAM).</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q6</span>
                            <p>Buffer pool l√† g√¨? T·∫°i sao quan tr·ªçng?</p>
                        </div>
                        <div class="answer">
                            <p>Memory cache cho data pages v√† indexes. Hit t·ª´ buffer pool ~100x faster than disk read.
                                Size = 70-80% RAM cho dedicated server. Monitor hit rate > 99%. Most important InnoDB
                                tuning parameter.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q7</span>
                            <p>Query cache trong MySQL 8.0?</p>
                        </div>
                        <div class="answer">
                            <p>Removed! Query cache c√≥ issues: single mutex (lock contention), invalidates on any write,
                                kh√¥ng scale. Thay th·∫ø b·∫±ng application-level caching (Redis, Memcached) v·ªõi better
                                control v√† scalability.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q8</span>
                            <p>Covering index gi√∫p g√¨?</p>
                        </div>
                        <div class="answer">
                            <p>Index ch·ª©a t·∫•t c·∫£ columns c·∫ßn cho query ‚Üí kh√¥ng c·∫ßn row lookup. "Using index" in EXPLAIN
                                Extra. Eliminates secondary lookup to clustered index. Best cho frequent queries v·ªõi
                                specific columns.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q9</span>
                            <p>Subquery vs JOIN performance?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>JOIN th∆∞·ªùng faster:</strong> Optimizer c√≥ nhi·ªÅu strategies</li>
                                <li><strong>Correlated subquery ch·∫≠m:</strong> Runs for each outer row</li>
                                <li><strong>Derived tables (FROM subquery):</strong> Materialized, may be OK</li>
                            </ul>
                            <p>MySQL 8.0+ optimizer c√≥ th·ªÉ transform subquery ‚Üí JOIN automatically.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q10</span>
                            <p>"Using filesort" nghƒ©a l√† g√¨?</p>
                        </div>
                        <div class="answer">
                            <p>MySQL ph·∫£i sort results sau khi fetch (not using index for ORDER BY). Extra sorting pass
                                = extra memory/disk. Fix: Create index matching ORDER BY clause ho·∫∑c ORDER BY primary
                                key columns.</p>
                        </div>
                    </div>
                </div>
            </section>

            <div class="page-navigation">
                <a href="transactions.html" class="nav-btn prev"><i
                        class="fas fa-arrow-left"></i><span>Transactions</span></a>
                <a href="design.html" class="nav-btn next"><span>Database Design</span><i
                        class="fas fa-arrow-right"></i></a>
            </div>
        </article>
    </main>

    <button class="back-to-top" id="backToTop"><i class="fas fa-arrow-up"></i></button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ini.min.js"></script>
    <script src="../js/main.js"></script>
</body>

</html>