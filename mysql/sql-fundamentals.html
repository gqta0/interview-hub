<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Fundamentals - MySQL Interview</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="../css/style.css">
</head>

<body>
    <div class="bg-animation"></div>

    <nav class="top-nav">
        <div class="nav-container">
            <a href="../index.html" class="nav-logo"><i class="fas fa-rocket"></i><span>Interview Hub</span></a>
            <a href="../index.html#mysql" class="nav-back"><i class="fas fa-arrow-left"></i> MySQL</a>
        </div>
    </nav>

    <header class="topic-header">
        <div class="topic-icon mysql"><i class="fas fa-database"></i></div>
        <div class="topic-info">
            <span class="topic-category">MySQL</span>
            <h1>SQL Fundamentals</h1>
            <p class="topic-desc">SELECT, JOIN, Subqueries, Aggregate Functions, Window Functions, CTEs</p>
        </div>
    </header>

    <main class="content-container">
        <aside class="toc">
            <h3><i class="fas fa-list"></i> N·ªôi dung</h3>
            <ul>
                <li><a href="#select">SELECT & Filtering</a></li>
                <li><a href="#operators">Operators & Functions</a></li>
                <li><a href="#joins">JOINs</a></li>
                <li><a href="#aggregate">Aggregate Functions</a></li>
                <li><a href="#subqueries">Subqueries</a></li>
                <li><a href="#window">Window Functions</a></li>
                <li><a href="#cte">CTEs</a></li>
                <li><a href="#set-operations">Set Operations</a></li>
                <li><a href="#dml">DML Operations</a></li>
                <li><a href="#interview">C√¢u h·ªèi ph·ªèng v·∫•n</a></li>
            </ul>
        </aside>

        <article class="main-content">
            <!-- SELECT & FILTERING -->
            <section class="content-section">
                <h2 id="select" class="section-title"><span class="section-icon">üìã</span>SELECT & Filtering</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Query Execution Order</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Written
                                    vs Execution Order</span></div>
                            <pre><code class="language-sql">-- Written order (c√°ch vi·∫øt):
SELECT column           -- 5. Ch·ªçn c·ªôt
FROM table              -- 1. T·ª´ b·∫£ng n√†o
WHERE condition         -- 2. L·ªçc rows
GROUP BY column         -- 3. Nh√≥m
HAVING condition        -- 4. L·ªçc groups
ORDER BY column         -- 6. S·∫Øp x·∫øp
LIMIT n OFFSET m;       -- 7. Gi·ªõi h·∫°n

-- Th·ª© t·ª± th·ª±c thi th·ª±c s·ª±:
-- 1. FROM + JOINs     ‚Üí X√°c ƒë·ªãnh ngu·ªìn d·ªØ li·ªáu
-- 2. WHERE            ‚Üí L·ªçc rows (tr∆∞·ªõc khi group)
-- 3. GROUP BY         ‚Üí Nh√≥m c√°c rows
-- 4. HAVING           ‚Üí L·ªçc groups (sau khi aggregate)
-- 5. SELECT           ‚Üí Ch·ªçn columns v√† compute
-- 6. DISTINCT         ‚Üí Lo·∫°i b·ªè duplicates
-- 7. ORDER BY         ‚Üí S·∫Øp x·∫øp k·∫øt qu·∫£
-- 8. LIMIT/OFFSET     ‚Üí Pagination</code></pre>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> L∆∞u √Ω quan tr·ªçng</h4>
                            <ul>
                                <li><strong>Alias trong SELECT:</strong> Kh√¥ng d√πng ƒë∆∞·ª£c trong WHERE (v√¨ SELECT ch·∫°y
                                    sau)</li>
                                <li><strong>Alias trong ORDER BY:</strong> D√πng ƒë∆∞·ª£c (ORDER BY ch·∫°y sau SELECT)</li>
                                <li><strong>Aggregate trong WHERE:</strong> Kh√¥ng ƒë∆∞·ª£c! Ph·∫£i d√πng HAVING</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Filtering v·ªõi WHERE</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">WHERE
                                    Clause Examples</span></div>
                            <pre><code class="language-sql">-- Comparison operators
SELECT * FROM products WHERE price > 100;
SELECT * FROM products WHERE price >= 100 AND price <= 500;
SELECT * FROM products WHERE price <> 100;  -- Not equal (ho·∫∑c !=)

-- BETWEEN (inclusive c·∫£ 2 ƒë·∫ßu)
SELECT * FROM orders WHERE amount BETWEEN 100 AND 500;
-- T∆∞∆°ng ƒë∆∞∆°ng: amount >= 100 AND amount <= 500

-- IN clause (list of values)
SELECT * FROM users WHERE role IN ('ADMIN', 'MANAGER', 'SUPERVISOR');
SELECT * FROM orders WHERE status NOT IN ('CANCELLED', 'REFUNDED');

-- LIKE patterns (% = any chars, _ = single char)
SELECT * FROM users WHERE email LIKE '%@gmail.com';       -- Ends with
SELECT * FROM users WHERE name LIKE 'John%';              -- Starts with
SELECT * FROM users WHERE name LIKE '%son%';              -- Contains
SELECT * FROM users WHERE phone LIKE '09________';        -- 09 + 8 digits
SELECT * FROM products WHERE code LIKE 'ABC\_123%' ESCAPE '\';  -- Escape _

-- NULL handling (NULL kh√¥ng = NULL!)
SELECT * FROM users WHERE deleted_at IS NULL;
SELECT * FROM users WHERE phone IS NOT NULL;
-- ‚ùå SAI: WHERE phone = NULL (lu√¥n FALSE)

-- AND, OR, NOT v·ªõi parentheses
SELECT * FROM products 
WHERE (category = 'Electronics' OR category = 'Computers')
  AND price < 1000 
  AND stock > 0;

-- DISTINCT (lo·∫°i duplicates)
SELECT DISTINCT department FROM employees;
SELECT DISTINCT department, city FROM employees;  -- Combination unique

-- ORDER BY (ASC m·∫∑c ƒë·ªãnh, DESC gi·∫£m d·∫ßn)
SELECT * FROM users ORDER BY created_at DESC, name ASC;
SELECT * FROM users ORDER BY 2, 1;  -- By column position (kh√¥ng recommend)
SELECT * FROM users ORDER BY FIELD(status, 'ACTIVE', 'PENDING', 'INACTIVE');

-- LIMIT & OFFSET (Pagination)
SELECT * FROM users ORDER BY id LIMIT 10;               -- First 10
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;     -- Skip 20, take 10 (page 3)  
SELECT * FROM users ORDER BY id LIMIT 20, 10;           -- MySQL shorthand: OFFSET, LIMIT</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- OPERATORS & FUNCTIONS -->
            <section class="content-section">
                <h2 id="operators" class="section-title"><span class="section-icon">‚öôÔ∏è</span>Operators & Functions</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Conditional Expressions</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">CASE,
                                    COALESCE, NULLIF</span></div>
                            <pre><code class="language-sql">-- CASE WHEN (if-else trong SQL)
SELECT 
    name,
    salary,
    CASE 
        WHEN salary >= 100000 THEN 'Senior'
        WHEN salary >= 50000 THEN 'Mid-level'
        WHEN salary >= 20000 THEN 'Junior'
        ELSE 'Intern'
    END AS level
FROM employees;

-- CASE ƒë∆°n gi·∫£n (exact match)
SELECT 
    order_id,
    CASE status
        WHEN 'P' THEN 'Pending'
        WHEN 'S' THEN 'Shipped'
        WHEN 'D' THEN 'Delivered'
        WHEN 'C' THEN 'Cancelled'
        ELSE 'Unknown'
    END AS status_label
FROM orders;

-- COALESCE (tr·∫£ v·ªÅ gi√° tr·ªã non-NULL ƒë·∫ßu ti√™n)
SELECT 
    name,
    COALESCE(phone, email, 'No contact') AS contact,
    COALESCE(discount, 0) AS actual_discount
FROM customers;

-- NULLIF (tr·∫£ v·ªÅ NULL n·∫øu 2 gi√° tr·ªã b·∫±ng nhau)
-- H·ªØu √≠ch ƒë·ªÉ tr√°nh division by zero
SELECT 
    revenue / NULLIF(cost, 0) AS margin_ratio  -- NULL thay v√¨ error
FROM products;

-- IF (MySQL specific)
SELECT 
    name,
    IF(stock > 0, 'In Stock', 'Out of Stock') AS availability,
    IF(price > 100, price * 0.9, price) AS final_price  -- 10% off if > 100
FROM products;

-- IFNULL (MySQL - t∆∞∆°ng t·ª± COALESCE nh∆∞ng ch·ªâ 2 args)
SELECT IFNULL(phone, 'N/A') FROM customers;</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>NULL Handling Functions</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Function</th>
                                        <th>Description</th>
                                        <th>Example</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>COALESCE(a,b,c)</code></td>
                                        <td>First non-NULL value</td>
                                        <td><code>COALESCE(NULL, 'a', 'b')</code> ‚Üí 'a'</td>
                                    </tr>
                                    <tr>
                                        <td><code>IFNULL(a,b)</code></td>
                                        <td>If a is NULL, return b</td>
                                        <td><code>IFNULL(NULL, 'default')</code> ‚Üí 'default'</td>
                                    </tr>
                                    <tr>
                                        <td><code>NULLIF(a,b)</code></td>
                                        <td>If a=b, return NULL</td>
                                        <td><code>NULLIF(0, 0)</code> ‚Üí NULL</td>
                                    </tr>
                                    <tr>
                                        <td><code>IF(cond,a,b)</code></td>
                                        <td>If true return a, else b</td>
                                        <td><code>IF(1>0, 'yes', 'no')</code> ‚Üí 'yes'</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>String & Date Functions</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Common
                                    Functions</span></div>
                            <pre><code class="language-sql">-- STRING FUNCTIONS
SELECT 
    CONCAT(first_name, ' ', last_name) AS full_name,
    CONCAT_WS(', ', city, state, country) AS address,  -- With separator
    UPPER(name), LOWER(name),
    LENGTH(name), CHAR_LENGTH(name),  -- Bytes vs characters
    TRIM('  hello  '), LTRIM(name), RTRIM(name),
    SUBSTRING(phone, 1, 3) AS area_code,  -- 3 chars from position 1
    LEFT(email, 5), RIGHT(email, 10),
    REPLACE(phone, '-', ''),
    REVERSE(name),
    LPAD(id, 5, '0') AS padded_id,  -- '00123'
    LOCATE('@', email) AS at_position  -- Position of @
FROM users;

-- DATE FUNCTIONS
SELECT 
    NOW() AS current_datetime,
    CURDATE() AS current_date,
    CURTIME() AS current_time,
    
    -- Extract parts
    YEAR(created_at), MONTH(created_at), DAY(created_at),
    HOUR(created_at), MINUTE(created_at), SECOND(created_at),
    WEEKDAY(created_at),  -- 0=Monday, 6=Sunday
    DAYOFWEEK(created_at),  -- 1=Sunday, 7=Saturday
    QUARTER(created_at),
    
    -- Date formatting
    DATE_FORMAT(created_at, '%Y-%m-%d') AS formatted_date,
    DATE_FORMAT(created_at, '%d/%m/%Y %H:%i') AS vn_format,
    
    -- Date arithmetic
    DATE_ADD(created_at, INTERVAL 30 DAY) AS plus_30_days,
    DATE_SUB(created_at, INTERVAL 1 MONTH) AS minus_1_month,
    DATEDIFF(NOW(), created_at) AS days_since_creation,
    TIMESTAMPDIFF(HOUR, start_time, end_time) AS hours_diff,
    
    -- Useful functions
    LAST_DAY(created_at) AS last_day_of_month,
    DATE(created_at) AS date_only,  -- Strip time
    TIME(created_at) AS time_only
FROM orders;

-- DATE_FORMAT codes:
-- %Y = 2024, %y = 24, %m = 01-12, %d = 01-31
-- %H = 00-23, %i = 00-59, %s = 00-59
-- %W = Weekday name, %M = Month name</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- JOINS -->
            <section class="content-section">
                <h2 id="joins" class="section-title"><span class="section-icon">üîó</span>JOINs</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>JOIN Types Visual</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">Visual</span><span class="code-title">JOIN
                                    Types Diagram</span></div>
                            <pre><code>INNER JOIN:          LEFT JOIN:           RIGHT JOIN:          FULL OUTER JOIN:
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚ï±   A     ‚ï≤          ‚ï±‚ñà‚ñà‚ñàA‚ñà‚ñà‚ñà‚ñà‚ï≤          ‚ï±   A     ‚ï≤          ‚ï±‚ñà‚ñà‚ñàA‚ñà‚ñà‚ñà‚ñà‚ï≤
 ‚îÇ     ‚ñà‚ñà‚ñà   ‚îÇ        ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ        ‚îÇ     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà       ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚ï≤   B     ‚ï±          ‚ï≤   B   ‚ï±          ‚ï≤‚ñà‚ñà‚ñà‚ñàB‚ñà‚ñà‚ñà‚ñà‚ï±          ‚ï≤‚ñà‚ñà‚ñàB‚ñà‚ñà‚ñà‚ñà‚ï±
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 Only matching        All A + match       Match + All B       All from both

LEFT EXCLUSIVE:      RIGHT EXCLUSIVE:     OUTER EXCLUSIVE:
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚ï±‚ñà‚ñà‚ñàA‚ñà‚ñà‚ñà‚ñà‚ï≤          ‚ï±   A     ‚ï≤          ‚ï±‚ñà‚ñà‚ñàA‚ñà‚ñà‚ñà‚ñà‚ï≤
 ‚îÇ ‚ñà‚ñà‚ñà     ‚îÇ        ‚îÇ       ‚ñà‚ñà‚ñà‚îÇ         ‚îÇ ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà ‚îÇ
  ‚ï≤       ‚ï±          ‚ï≤‚ñà‚ñà‚ñà‚ñàB‚ñà‚ñà‚ñà‚ñà‚ï±          ‚ï≤‚ñà‚ñà‚ñàB‚ñà‚ñà‚ñà‚ñà‚ï±
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 A only (no B)       B only (no A)       A or B (not both)</code></pre>
                        </div>
                    </div>
                </div>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>JOIN Examples</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">All JOIN
                                    Types</span></div>
                            <pre><code class="language-sql">-- Sample tables:
-- users: id, name, email
-- orders: id, user_id, amount, created_at
-- products: id, name, price

-- INNER JOIN: Ch·ªâ l·∫•y rows kh·ªõp c·∫£ 2 b·∫£ng
SELECT u.name, o.id AS order_id, o.amount
FROM users u
INNER JOIN orders o ON u.id = o.user_id;
-- Users kh√¥ng c√≥ orders s·∫Ω KH√îNG xu·∫•t hi·ªán

-- LEFT JOIN: T·∫•t c·∫£ t·ª´ b·∫£ng tr√°i + kh·ªõp t·ª´ ph·∫£i
SELECT u.name, o.id AS order_id, o.amount
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
-- Users kh√¥ng c√≥ orders v·∫´n xu·∫•t hi·ªán (order columns = NULL)

-- LEFT JOIN EXCLUSIVE: Ch·ªâ l·∫•y A kh√¥ng c√≥ B
-- T√¨m users KH√îNG c√≥ orders
SELECT u.name, u.email
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
WHERE o.id IS NULL;

-- RIGHT JOIN: Ng∆∞·ª£c v·ªõi LEFT
SELECT u.name, o.id AS order_id
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;

-- FULL OUTER JOIN (MySQL kh√¥ng h·ªó tr·ª£ tr·ª±c ti·∫øp - d√πng UNION)
SELECT u.name, o.id AS order_id
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
UNION
SELECT u.name, o.id AS order_id
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;

-- Multiple JOINs
SELECT 
    u.name AS customer,
    o.id AS order_id,
    p.name AS product,
    oi.quantity,
    p.price * oi.quantity AS subtotal
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.status = 'COMPLETED';

-- Self JOIN (b·∫£ng t·ª± join v·ªõi ch√≠nh n√≥)
-- V√≠ d·ª•: T√¨m manager c·ªßa m·ªói employee
SELECT 
    e.name AS employee,
    m.name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- CROSS JOIN (Cartesian Product - m·ªói row A v·ªõi m·ªçi row B)
SELECT c.name AS color, s.name AS size
FROM colors c
CROSS JOIN sizes s;
-- 3 colors x 4 sizes = 12 rows

-- JOIN v·ªõi ƒëi·ªÅu ki·ªán ph·ª©c t·∫°p
SELECT *
FROM products p
JOIN discounts d ON p.category_id = d.category_id
                 AND CURDATE() BETWEEN d.start_date AND d.end_date;

-- USING syntax (khi column name gi·ªëng nhau)
SELECT *
FROM orders o
JOIN order_items oi USING (order_id);  -- T∆∞∆°ng ƒë∆∞∆°ng ON o.order_id = oi.order_id

-- NATURAL JOIN (t·ª± ƒë·ªông match all same-name columns - KH√îNG recommend)
SELECT * FROM orders NATURAL JOIN order_items;  -- Dangerous!</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>JOIN Comparison</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Returns</th>
                                        <th>Use When</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>INNER</strong></td>
                                        <td>Matching rows only</td>
                                        <td>Ch·ªâ c·∫ßn data c√≥ match</td>
                                    </tr>
                                    <tr>
                                        <td><strong>LEFT</strong></td>
                                        <td>All left + matching right</td>
                                        <td>Gi·ªØ t·∫•t c·∫£ t·ª´ b·∫£ng ch√≠nh</td>
                                    </tr>
                                    <tr>
                                        <td><strong>RIGHT</strong></td>
                                        <td>All right + matching left</td>
                                        <td>√çt d√πng (vi·∫øt l·∫°i th√†nh LEFT)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>CROSS</strong></td>
                                        <td>Cartesian (all combinations)</td>
                                        <td>Generate combinations</td>
                                    </tr>
                                    <tr>
                                        <td><strong>SELF</strong></td>
                                        <td>Table with itself</td>
                                        <td>Hierarchical data</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> JOIN Performance Tips</h4>
                            <ul>
                                <li><strong>C√≥ index tr√™n JOIN columns:</strong> ƒê·∫∑c bi·ªát foreign keys</li>
                                <li><strong>Filter s·ªõm:</strong> WHERE tr∆∞·ªõc (ho·∫∑c trong ON clause) ƒë·ªÉ gi·∫£m dataset</li>
                                <li><strong>Tr√°nh functions tr√™n JOIN columns:</strong>
                                    <code>ON YEAR(a.date) = YEAR(b.date)</code> kh√¥ng d√πng index</li>
                                <li><strong>Nh·ªè JOIN l·ªõn:</strong> Put smaller table first (optimizer usually handles
                                    this)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- AGGREGATE FUNCTIONS -->
            <section class="content-section">
                <h2 id="aggregate" class="section-title"><span class="section-icon">üìä</span>Aggregate Functions</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>GROUP BY & Aggregations</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Aggregate Functions</span></div>
                            <pre><code class="language-sql">-- Basic aggregates
SELECT 
    COUNT(*) AS total_orders,              -- ƒê·∫øm t·∫•t c·∫£ rows (k·ªÉ c·∫£ NULL)
    COUNT(discount) AS with_discount,      -- ƒê·∫øm non-NULL values
    COUNT(DISTINCT user_id) AS unique_customers,
    SUM(amount) AS total_amount,
    AVG(amount) AS avg_amount,
    MIN(amount) AS min_amount,
    MAX(amount) AS max_amount,
    STD(amount) AS standard_deviation,     -- MySQL
    VARIANCE(amount) AS variance
FROM orders;

-- GROUP BY single column
SELECT 
    user_id,
    COUNT(*) AS order_count,
    SUM(amount) AS total_spent,
    AVG(amount) AS avg_order,
    MIN(created_at) AS first_order,
    MAX(created_at) AS last_order
FROM orders
GROUP BY user_id;

-- GROUP BY multiple columns
SELECT 
    YEAR(created_at) AS year,
    MONTH(created_at) AS month,
    COUNT(*) AS orders,
    SUM(amount) AS revenue
FROM orders
GROUP BY YEAR(created_at), MONTH(created_at)
ORDER BY year DESC, month DESC;

-- HAVING (filter AFTER aggregation)
SELECT 
    user_id,
    COUNT(*) AS order_count,
    SUM(amount) AS total_spent
FROM orders
GROUP BY user_id
HAVING COUNT(*) >= 5 AND SUM(amount) > 1000;
-- ‚ö†Ô∏è Cannot use alias in HAVING in some SQL!

-- WHERE vs HAVING
SELECT 
    category_id,
    AVG(price) AS avg_price
FROM products
WHERE status = 'ACTIVE'          -- 1. Filter rows BEFORE grouping
GROUP BY category_id
HAVING AVG(price) > 100;         -- 2. Filter groups AFTER aggregation

-- GROUP_CONCAT (MySQL specific - combine values into string)
SELECT 
    category_id,
    GROUP_CONCAT(name ORDER BY name SEPARATOR ', ') AS products,
    GROUP_CONCAT(DISTINCT brand SEPARATOR ' | ') AS brands
FROM products
GROUP BY category_id;
-- Result: "Laptop, Mouse, Keyboard"

-- WITH ROLLUP (subtotals and grand total)
SELECT 
    COALESCE(category, 'TOTAL') AS category,
    COALESCE(brand, 'Subtotal') AS brand,
    COUNT(*) AS count,
    SUM(price) AS total
FROM products
GROUP BY category, brand WITH ROLLUP;

-- Conditional aggregation
SELECT 
    COUNT(*) AS total,
    SUM(CASE WHEN status = 'COMPLETED' THEN 1 ELSE 0 END) AS completed,
    SUM(CASE WHEN status = 'PENDING' THEN 1 ELSE 0 END) AS pending,
    SUM(CASE WHEN status = 'CANCELLED' THEN 1 ELSE 0 END) AS cancelled,
    AVG(CASE WHEN status = 'COMPLETED' THEN amount END) AS avg_completed_amount
FROM orders;</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>Aggregate Functions Summary</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Function</th>
                                        <th>Description</th>
                                        <th>NULL handling</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>COUNT(*)</code></td>
                                        <td>Count all rows</td>
                                        <td>Includes NULLs</td>
                                    </tr>
                                    <tr>
                                        <td><code>COUNT(col)</code></td>
                                        <td>Count non-NULL values</td>
                                        <td>Excludes NULLs</td>
                                    </tr>
                                    <tr>
                                        <td><code>SUM(col)</code></td>
                                        <td>Sum of values</td>
                                        <td>Ignores NULLs</td>
                                    </tr>
                                    <tr>
                                        <td><code>AVG(col)</code></td>
                                        <td>Average</td>
                                        <td>Ignores NULLs</td>
                                    </tr>
                                    <tr>
                                        <td><code>MIN/MAX(col)</code></td>
                                        <td>Minimum/Maximum</td>
                                        <td>Ignores NULLs</td>
                                    </tr>
                                    <tr>
                                        <td><code>GROUP_CONCAT</code></td>
                                        <td>Concatenate values</td>
                                        <td>Ignores NULLs</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- SUBQUERIES -->
            <section class="content-section">
                <h2 id="subqueries" class="section-title"><span class="section-icon">üîÑ</span>Subqueries</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Subquery Types</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Subquery
                                    Examples</span></div>
                            <pre><code class="language-sql">-- 1. SCALAR SUBQUERY (tr·∫£ v·ªÅ 1 gi√° tr·ªã duy nh·∫•t)
SELECT 
    name,
    salary,
    (SELECT AVG(salary) FROM employees) AS company_avg,
    salary - (SELECT AVG(salary) FROM employees) AS diff_from_avg
FROM employees;

-- 2. COLUMN SUBQUERY (tr·∫£ v·ªÅ 1 c·ªôt, nhi·ªÅu rows)
-- IN clause
SELECT * FROM users
WHERE id IN (
    SELECT DISTINCT user_id 
    FROM orders 
    WHERE amount > 1000
);

-- NOT IN (c·∫©n th·∫≠n v·ªõi NULL!)
SELECT * FROM products
WHERE category_id NOT IN (
    SELECT id FROM categories WHERE status = 'INACTIVE'
);
-- ‚ö†Ô∏è N·∫øu subquery tr·∫£ v·ªÅ NULL ‚Üí to√†n b·ªô NOT IN = FALSE!

-- 3. ROW SUBQUERY (tr·∫£ v·ªÅ 1 row)
SELECT * FROM employees
WHERE (department_id, salary) = (
    SELECT department_id, MAX(salary)
    FROM employees
    WHERE department_id = 1
);

-- 4. TABLE SUBQUERY / Derived Table (trong FROM)
SELECT dept_stats.department, dept_stats.avg_salary
FROM (
    SELECT department_id, department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department_id, department
) AS dept_stats
WHERE dept_stats.avg_salary > 50000;

-- 5. CORRELATED SUBQUERY (references outer query - ch·∫°y cho m·ªói row)
-- Employees c√≥ salary cao h∆°n avg c·ªßa department m√¨nh
SELECT e.name, e.salary, e.department_id
FROM employees e
WHERE e.salary > (
    SELECT AVG(e2.salary) 
    FROM employees e2 
    WHERE e2.department_id = e.department_id  -- Correlated!
);

-- 6. EXISTS (ki·ªÉm tra c√≥ row t·ªìn t·∫°i kh√¥ng)
SELECT * FROM users u
WHERE EXISTS (
    SELECT 1 
    FROM orders o 
    WHERE o.user_id = u.id AND o.amount > 1000
);

-- NOT EXISTS (t√¨m users kh√¥ng c√≥ orders)
SELECT * FROM users u
WHERE NOT EXISTS (
    SELECT 1 FROM orders o WHERE o.user_id = u.id
);

-- EXISTS vs IN comparison
-- EXISTS: T·ªët khi outer table nh·ªè h∆°n, stops at first match
-- IN: T·ªët khi subquery result nh·ªè

-- 7. Subquery in SELECT, WHERE, FROM, HAVING
-- SELECT:
SELECT name, (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) AS order_count
FROM users u;

-- WHERE:
SELECT * FROM products WHERE price > (SELECT AVG(price) FROM products);

-- HAVING:
SELECT category_id, AVG(price) AS avg_price
FROM products
GROUP BY category_id
HAVING AVG(price) > (SELECT AVG(price) FROM products);</code></pre>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> Subquery Performance</h4>
                            <ul>
                                <li><strong>Correlated subqueries:</strong> Ch·∫°y cho T·ª™NG row c·ªßa outer query ‚Üí c√≥ th·ªÉ
                                    r·∫•t ch·∫≠m!</li>
                                <li><strong>Thay th·∫ø b·∫±ng JOIN:</strong> Th∆∞·ªùng hi·ªáu qu·∫£ h∆°n subquery</li>
                                <li><strong>EXISTS vs IN:</strong> EXISTS t·ªët h∆°n v·ªõi large datasets (short-circuit)
                                </li>
                                <li><strong>Materialized subquery:</strong> MySQL c√≥ th·ªÉ cache subquery result</li>
                            </ul>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Subquery
                                    ‚Üí JOIN Conversion</span></div>
                            <pre><code class="language-sql">-- ‚ùå Subquery (c√≥ th·ªÉ ch·∫≠m)
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders WHERE amount > 1000);

-- ‚úÖ JOIN (th∆∞·ªùng nhanh h∆°n)
SELECT DISTINCT u.*
FROM users u
JOIN orders o ON u.id = o.user_id
WHERE o.amount > 1000;

-- ‚ùå Correlated subquery
SELECT 
    name,
    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) AS order_count
FROM users u;

-- ‚úÖ LEFT JOIN + GROUP BY
SELECT u.name, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- WINDOW FUNCTIONS -->
            <section class="content-section">
                <h2 id="window" class="section-title"><span class="section-icon">ü™ü</span>Window Functions</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>Analytic Functions</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Window
                                    Function Syntax</span></div>
                            <pre><code class="language-sql">-- Basic syntax
function_name() OVER (
    [PARTITION BY column]      -- Reset cho m·ªói partition (nh∆∞ GROUP BY)
    [ORDER BY column]          -- Th·ª© t·ª± trong partition
    [ROWS/RANGE frame_clause]  -- Window frame (optional)
)

-- ROW_NUMBER: S·ªë th·ª© t·ª± unique (1,2,3,4,5...)
SELECT 
    name, department, salary,
    ROW_NUMBER() OVER (ORDER BY salary DESC) AS overall_rank,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_rank
FROM employees;

-- RANK vs DENSE_RANK (handling ties)
SELECT 
    name, salary,
    RANK() OVER (ORDER BY salary DESC) AS rank,        -- 1,2,2,4 (skip)
    DENSE_RANK() OVER (ORDER BY salary DESC) AS dense  -- 1,2,2,3 (no skip)
FROM employees;
-- Salary: 100, 90, 90, 80
-- RANK:     1,  2,  2,  4  (skips 3)
-- DENSE:    1,  2,  2,  3  (no skip)

-- NTILE: Chia th√†nh n buckets ƒë·ªÅu nhau
SELECT 
    name, salary,
    NTILE(4) OVER (ORDER BY salary DESC) AS quartile,  -- 1,2,3,4
    NTILE(10) OVER (ORDER BY salary DESC) AS decile    -- 1-10
FROM employees;

-- LAG/LEAD: Access previous/next row
SELECT 
    order_date,
    amount,
    LAG(amount, 1, 0) OVER (ORDER BY order_date) AS prev_amount,
    LEAD(amount, 1, 0) OVER (ORDER BY order_date) AS next_amount,
    amount - LAG(amount, 1, 0) OVER (ORDER BY order_date) AS change
FROM orders;
-- LAG(column, offset, default_value)

-- FIRST_VALUE / LAST_VALUE / NTH_VALUE
SELECT 
    name, department, salary,
    FIRST_VALUE(name) OVER (
        PARTITION BY department ORDER BY salary DESC
    ) AS top_earner,
    LAST_VALUE(name) OVER (
        PARTITION BY department 
        ORDER BY salary DESC
        ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
    ) AS lowest_earner
FROM employees;

-- Running totals / Moving averages
SELECT 
    order_date,
    amount,
    
    -- Running total
    SUM(amount) OVER (ORDER BY order_date) AS running_total,
    
    -- Cumulative average
    AVG(amount) OVER (ORDER BY order_date) AS cumulative_avg,
    
    -- Moving average (last 7 days)
    AVG(amount) OVER (
        ORDER BY order_date 
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS moving_avg_7,
    
    -- Percentage of total
    amount * 100.0 / SUM(amount) OVER () AS pct_of_total,
    
    -- Percentage within department
    amount * 100.0 / SUM(amount) OVER (PARTITION BY department) AS pct_in_dept
FROM orders;

-- Window Frame clauses
-- ROWS: Physical rows
-- RANGE: Logical range of values
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW  -- Default
ROWS BETWEEN 3 PRECEDING AND 3 FOLLOWING          -- 7-row window
ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
RANGE BETWEEN INTERVAL 7 DAY PRECEDING AND CURRENT ROW  -- Last 7 days</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>Common Window Functions</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Function</th>
                                        <th>Description</th>
                                        <th>Use Case</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>ROW_NUMBER()</code></td>
                                        <td>Unique row number</td>
                                        <td>Pagination, deduplication</td>
                                    </tr>
                                    <tr>
                                        <td><code>RANK()</code></td>
                                        <td>Rank with gaps</td>
                                        <td>Competition ranking</td>
                                    </tr>
                                    <tr>
                                        <td><code>DENSE_RANK()</code></td>
                                        <td>Rank without gaps</td>
                                        <td>Continuous ranking</td>
                                    </tr>
                                    <tr>
                                        <td><code>NTILE(n)</code></td>
                                        <td>Divide into n buckets</td>
                                        <td>Quartiles, percentiles</td>
                                    </tr>
                                    <tr>
                                        <td><code>LAG(col, n)</code></td>
                                        <td>Value n rows before</td>
                                        <td>Compare with previous</td>
                                    </tr>
                                    <tr>
                                        <td><code>LEAD(col, n)</code></td>
                                        <td>Value n rows after</td>
                                        <td>Compare with next</td>
                                    </tr>
                                    <tr>
                                        <td><code>FIRST_VALUE()</code></td>
                                        <td>First value in window</td>
                                        <td>Category leader</td>
                                    </tr>
                                    <tr>
                                        <td><code>SUM() OVER()</code></td>
                                        <td>Running/window sum</td>
                                        <td>Cumulative totals</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span
                                    class="code-title">Practical Examples</span></div>
                            <pre><code class="language-sql">-- Top N per group (Top 3 products per category)
WITH ranked AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY sales DESC) AS rn
    FROM products
)
SELECT * FROM ranked WHERE rn <= 3;

-- Deduplication (keep latest)
WITH ranked AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY email ORDER BY created_at DESC) AS rn
    FROM users
)
DELETE FROM users WHERE id IN (SELECT id FROM ranked WHERE rn > 1);

-- Year-over-year comparison
SELECT 
    year,
    month,
    revenue,
    LAG(revenue, 12) OVER (ORDER BY year, month) AS prev_year_revenue,
    (revenue - LAG(revenue, 12) OVER (ORDER BY year, month)) / 
        LAG(revenue, 12) OVER (ORDER BY year, month) * 100 AS yoy_growth_pct
FROM monthly_sales;</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- CTEs -->
            <section class="content-section">
                <h2 id="cte" class="section-title"><span class="section-icon">üìù</span>CTEs (Common Table Expressions)
                </h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>WITH Clause</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">CTE
                                    Examples</span></div>
                            <pre><code class="language-sql">-- Basic CTE
WITH active_users AS (
    SELECT id, name, email
    FROM users
    WHERE status = 'ACTIVE' AND created_at > '2024-01-01'
)
SELECT * FROM active_users WHERE name LIKE 'John%';

-- Multiple CTEs
WITH 
    active_users AS (
        SELECT id, name FROM users WHERE status = 'ACTIVE'
    ),
    user_stats AS (
        SELECT 
            user_id, 
            COUNT(*) AS order_count,
            SUM(amount) AS total_spent
        FROM orders
        WHERE status = 'COMPLETED'
        GROUP BY user_id
    )
SELECT 
    u.name,
    COALESCE(s.order_count, 0) AS orders,
    COALESCE(s.total_spent, 0) AS spent
FROM active_users u
LEFT JOIN user_stats s ON u.id = s.user_id
ORDER BY s.total_spent DESC;

-- CTE referencing another CTE
WITH 
    monthly_sales AS (
        SELECT 
            DATE_FORMAT(created_at, '%Y-%m') AS month,
            SUM(amount) AS revenue
        FROM orders
        GROUP BY DATE_FORMAT(created_at, '%Y-%m')
    ),
    sales_with_growth AS (
        SELECT 
            month,
            revenue,
            LAG(revenue) OVER (ORDER BY month) AS prev_revenue
        FROM monthly_sales
    )
SELECT 
    month,
    revenue,
    prev_revenue,
    ROUND((revenue - prev_revenue) / prev_revenue * 100, 2) AS growth_pct
FROM sales_with_growth
WHERE prev_revenue IS NOT NULL;

-- RECURSIVE CTE (cho hierarchical data)
WITH RECURSIVE org_tree AS (
    -- Base case: Top-level (no manager)
    SELECT 
        id, 
        name, 
        manager_id, 
        1 AS level,
        CAST(name AS CHAR(500)) AS path
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: employees with managers
    SELECT 
        e.id, 
        e.name, 
        e.manager_id, 
        ot.level + 1,
        CONCAT(ot.path, ' > ', e.name)
    FROM employees e
    INNER JOIN org_tree ot ON e.manager_id = ot.id
)
SELECT * FROM org_tree ORDER BY level, name;

-- Recursive: Number sequence
WITH RECURSIVE nums AS (
    SELECT 1 AS n
    UNION ALL
    SELECT n + 1 FROM nums WHERE n < 100
)
SELECT * FROM nums;

-- Recursive: Date series
WITH RECURSIVE date_series AS (
    SELECT DATE('2024-01-01') AS date
    UNION ALL
    SELECT date + INTERVAL 1 DAY FROM date_series WHERE date < '2024-12-31'
)
SELECT 
    ds.date,
    COALESCE(SUM(o.amount), 0) AS daily_revenue
FROM date_series ds
LEFT JOIN orders o ON DATE(o.created_at) = ds.date
GROUP BY ds.date;</code></pre>
                        </div>

                        <div class="info-box">
                            <h4><i class="fas fa-lightbulb"></i> CTE Benefits</h4>
                            <ul>
                                <li><strong>Readability:</strong> Named subqueries d·ªÖ ƒë·ªçc h∆°n nested subqueries</li>
                                <li><strong>Reusability:</strong> CTE c√≥ th·ªÉ reference nhi·ªÅu l·∫ßn trong main query</li>
                                <li><strong>Recursive:</strong> Gi·∫£i quy·∫øt hierarchical data (org charts, categories)
                                </li>
                                <li><strong>Optimization:</strong> MySQL th∆∞·ªùng inline CTE (nh∆∞ subquery)</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- SET OPERATIONS -->
            <section class="content-section">
                <h2 id="set-operations" class="section-title"><span class="section-icon">üîÄ</span>Set Operations</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>UNION, INTERSECT, EXCEPT</h3><span class="badge important">Important</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">Set
                                    Operations</span></div>
                            <pre><code class="language-sql">-- UNION: Combine results (remove duplicates)
SELECT name, email FROM customers
UNION
SELECT name, email FROM suppliers;

-- UNION ALL: Combine results (keep duplicates - faster)
SELECT product_id, 'order' AS source FROM order_items
UNION ALL
SELECT product_id, 'wishlist' AS source FROM wishlist_items;

-- INTERSECT: Common rows (MySQL 8.0.31+)
SELECT product_id FROM order_items
INTERSECT
SELECT product_id FROM wishlist_items;
-- Products in both orders AND wishlists

-- Pre-MySQL 8.0.31: Use INNER JOIN instead
SELECT DISTINCT oi.product_id
FROM order_items oi
INNER JOIN wishlist_items wi ON oi.product_id = wi.product_id;

-- EXCEPT (MySQL 8.0.31+): Rows in first but not second
SELECT product_id FROM wishlist_items
EXCEPT
SELECT product_id FROM order_items;
-- Wishlisted but never ordered

-- Pre-MySQL 8.0.31: Use LEFT JOIN + IS NULL
SELECT DISTINCT wi.product_id
FROM wishlist_items wi
LEFT JOIN order_items oi ON wi.product_id = oi.product_id
WHERE oi.product_id IS NULL;</code></pre>
                        </div>

                        <div class="comparison-table">
                            <h4>Set Operations Rules</h4>
                            <table>
                                <thead>
                                    <tr>
                                        <th>Operation</th>
                                        <th>Result</th>
                                        <th>Requirement</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>UNION</strong></td>
                                        <td>A ‚à™ B (distinct)</td>
                                        <td>Same # columns, compatible types</td>
                                    </tr>
                                    <tr>
                                        <td><strong>UNION ALL</strong></td>
                                        <td>A + B (all rows)</td>
                                        <td>Same # columns, compatible types</td>
                                    </tr>
                                    <tr>
                                        <td><strong>INTERSECT</strong></td>
                                        <td>A ‚à© B</td>
                                        <td>Same # columns, compatible types</td>
                                    </tr>
                                    <tr>
                                        <td><strong>EXCEPT</strong></td>
                                        <td>A - B</td>
                                        <td>Same # columns, compatible types</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </section>

            <!-- DML OPERATIONS -->
            <section class="content-section">
                <h2 id="dml" class="section-title"><span class="section-icon">‚úèÔ∏è</span>DML Operations</h2>

                <div class="concept-card">
                    <div class="concept-header">
                        <h3>INSERT, UPDATE, DELETE</h3><span class="badge essential">Essential</span>
                    </div>
                    <div class="concept-content">
                        <div class="code-block">
                            <div class="code-header"><span class="code-lang">SQL</span><span class="code-title">DML
                                    Examples</span></div>
                            <pre><code class="language-sql">-- INSERT single row
INSERT INTO users (name, email, status) 
VALUES ('John Doe', 'john@example.com', 'ACTIVE');

-- INSERT multiple rows
INSERT INTO users (name, email, status) VALUES
    ('Alice', 'alice@example.com', 'ACTIVE'),
    ('Bob', 'bob@example.com', 'PENDING'),
    ('Charlie', 'charlie@example.com', 'ACTIVE');

-- INSERT from SELECT
INSERT INTO user_archive (id, name, email, archived_at)
SELECT id, name, email, NOW()
FROM users
WHERE status = 'DELETED';

-- INSERT IGNORE (skip duplicates)
INSERT IGNORE INTO users (email, name) VALUES ('john@example.com', 'John');

-- ON DUPLICATE KEY UPDATE (upsert)
INSERT INTO products (sku, name, price, stock)
VALUES ('ABC123', 'Widget', 29.99, 100)
ON DUPLICATE KEY UPDATE 
    price = VALUES(price),
    stock = stock + VALUES(stock);

-- REPLACE (delete + insert)
REPLACE INTO settings (key_name, value) VALUES ('theme', 'dark');

-- UPDATE basic
UPDATE users SET status = 'INACTIVE' WHERE last_login < '2023-01-01';

-- UPDATE multiple columns
UPDATE products 
SET 
    price = price * 1.1,
    updated_at = NOW()
WHERE category = 'Electronics';

-- UPDATE with JOIN
UPDATE orders o
JOIN users u ON o.user_id = u.id
SET o.shipping_address = u.address
WHERE o.shipping_address IS NULL;

-- UPDATE with subquery
UPDATE products 
SET category_id = (SELECT id FROM categories WHERE name = 'Electronics')
WHERE name LIKE '%Phone%';

-- UPDATE with LIMIT (process in batches)
UPDATE orders SET status = 'ARCHIVED' 
WHERE created_at < '2022-01-01' 
LIMIT 1000;

-- DELETE basic
DELETE FROM users WHERE status = 'DELETED' AND deleted_at < '2023-01-01';

-- DELETE with JOIN
DELETE o FROM orders o
JOIN users u ON o.user_id = u.id
WHERE u.status = 'DELETED';

-- DELETE with LIMIT
DELETE FROM logs WHERE created_at < '2023-01-01' LIMIT 10000;

-- TRUNCATE (delete all, reset auto_increment)
TRUNCATE TABLE temp_data;
-- vs DELETE FROM temp_data; (slower, keeps auto_increment)</code></pre>
                        </div>

                        <div class="warning-box">
                            <h4><i class="fas fa-exclamation-triangle"></i> DML Best Practices</h4>
                            <ul>
                                <li><strong>Always use WHERE:</strong> Tr∆∞·ªõc khi DELETE/UPDATE, SELECT tr∆∞·ªõc ƒë·ªÉ verify
                                </li>
                                <li><strong>Use transactions:</strong> Wrap trong transaction ƒë·ªÉ rollback n·∫øu l·ªói</li>
                                <li><strong>Batch large operations:</strong> D√πng LIMIT ƒë·ªÉ tr√°nh lock table qu√° l√¢u</li>
                                <li><strong>Backup tr∆∞·ªõc:</strong> ƒê·∫∑c bi·ªát v·ªõi production data</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- INTERVIEW QUESTIONS -->
            <section id="interview" class="content-section">
                <h2 class="section-title"><span class="section-icon">üíº</span>C√¢u H·ªèi Ph·ªèng V·∫•n</h2>

                <div class="interview-questions">
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q1</span>
                            <p>WHERE vs HAVING?</p>
                        </div>
                        <div class="answer">
                            <p><code>WHERE</code> l·ªçc rows TR∆Ø·ªöC grouping (execution step 2). <code>HAVING</code> l·ªçc
                                groups SAU aggregation (step 4). D√πng WHERE cho row conditions, HAVING cho aggregate
                                conditions nh∆∞ <code>HAVING COUNT(*) > 5</code>.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q2</span>
                            <p>LEFT JOIN vs INNER JOIN?</p>
                        </div>
                        <div class="answer">
                            <p><strong>INNER:</strong> Ch·ªâ tr·∫£ v·ªÅ rows match c·∫£ 2 b·∫£ng. <strong>LEFT:</strong> T·∫•t c·∫£
                                rows t·ª´ b·∫£ng tr√°i + matching t·ª´ ph·∫£i (NULL n·∫øu kh√¥ng match). D√πng LEFT khi mu·ªën gi·ªØ t·∫•t
                                c·∫£ t·ª´ b·∫£ng ch√≠nh.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q3</span>
                            <p>EXISTS vs IN?</p>
                        </div>
                        <div class="answer">
                            <p><code>EXISTS</code> tr·∫£ v·ªÅ true/false, d·ª´ng ngay khi t√¨m th·∫•y match ƒë·∫ßu ti√™n.
                                <code>IN</code> so s√°nh v·ªõi list values. EXISTS th∆∞·ªùng nhanh h∆°n v·ªõi large datasets v√¨
                                short-circuits. C·∫©n th·∫≠n: IN v·ªõi NULL trong subquery c√≥ th·ªÉ cho k·∫øt qu·∫£ kh√¥ng mong mu·ªën.
                            </p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q4</span>
                            <p>RANK vs DENSE_RANK vs ROW_NUMBER?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>ROW_NUMBER:</strong> S·ªë unique (1,2,3,4,5...)</li>
                                <li><strong>RANK:</strong> C√≥ gap khi tie (1,2,2,4 - skip 3)</li>
                                <li><strong>DENSE_RANK:</strong> Kh√¥ng gap (1,2,2,3)</li>
                            </ul>
                            <p>D√πng ROW_NUMBER cho pagination/deduplication, RANK cho competition ranking.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q5</span>
                            <p>CTE l√† g√¨? Khi n√†o d√πng?</p>
                        </div>
                        <div class="answer">
                            <p>Common Table Expression - named temporary result set v·ªõi <code>WITH</code> clause. D√πng
                                ƒë·ªÉ: (1) Improve readability thay v√¨ nested subqueries, (2) Reference nhi·ªÅu l·∫ßn trong
                                query, (3) Recursive queries cho hierarchical data (org chart, category tree).</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q6</span>
                            <p>UNION vs UNION ALL?</p>
                        </div>
                        <div class="answer">
                            <p><strong>UNION:</strong> G·ªôp results v√† lo·∫°i b·ªè duplicates (c√≥ sort). <strong>UNION
                                    ALL:</strong> G·ªôp t·∫•t c·∫£ rows k·ªÉ c·∫£ duplicates (nhanh h∆°n v√¨ kh√¥ng c·∫ßn
                                sort/compare). D√πng UNION ALL khi ch·∫Øc ch·∫Øn kh√¥ng c√≥ duplicates ho·∫∑c c·∫ßn gi·ªØ duplicates.
                            </p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q7</span>
                            <p>Subquery trong SELECT vs JOIN?</p>
                        </div>
                        <div class="answer">
                            <p>Correlated subquery trong SELECT ch·∫°y cho t·ª´ng row ‚Üí O(n¬≤) v·ªõi large tables. JOIN th∆∞·ªùng
                                hi·ªáu qu·∫£ h∆°n v√¨ optimizer c√≥ th·ªÉ ch·ªçn join strategy t·ªët nh·∫•t. Convert subquery ‚Üí LEFT
                                JOIN khi c√≥ th·ªÉ.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q8</span>
                            <p>COALESCE vs IFNULL?</p>
                        </div>
                        <div class="answer">
                            <p><code>IFNULL(a, b)</code>: MySQL specific, 2 arguments.
                                <code>COALESCE(a, b, c, ...)</code>: SQL standard, multiple arguments, tr·∫£ v·ªÅ first
                                non-NULL. Prefer COALESCE for portability v√† flexibility.</p>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q9</span>
                            <p>L√†m sao t√¨m Nth highest salary?</p>
                        </div>
                        <div class="answer">
                            <pre><code class="language-sql">-- Using DENSE_RANK
WITH ranked AS (
    SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) AS rn
    FROM employees
)
SELECT DISTINCT salary FROM ranked WHERE rn = 3;

-- Using LIMIT OFFSET
SELECT DISTINCT salary FROM employees 
ORDER BY salary DESC LIMIT 1 OFFSET 2;</code></pre>
                        </div>
                    </div>
                    <div class="question-card">
                        <div class="question"><span class="q-number">Q10</span>
                            <p>DELETE vs TRUNCATE?</p>
                        </div>
                        <div class="answer">
                            <ul>
                                <li><strong>DELETE:</strong> DML, row-by-row, can use WHERE, triggers fire, can
                                    rollback, keeps auto_increment</li>
                                <li><strong>TRUNCATE:</strong> DDL, drop & recreate table, no WHERE, no triggers,
                                    faster, resets auto_increment</li>
                            </ul>
                            <p>D√πng TRUNCATE ƒë·ªÉ clear entire table nhanh, DELETE khi c·∫ßn filter ho·∫∑c trigger.</p>
                        </div>
                    </div>
                </div>
            </section>

            <div class="page-navigation">
                <a href="../index.html#mysql" class="nav-btn prev"><i
                        class="fas fa-arrow-left"></i><span>MySQL</span></a>
                <a href="indexing.html" class="nav-btn next"><span>Indexing</span><i class="fas fa-arrow-right"></i></a>
            </div>
        </article>
    </main>

    <button class="back-to-top" id="backToTop"><i class="fas fa-arrow-up"></i></button>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
    <script src="../js/main.js"></script>
</body>

</html>